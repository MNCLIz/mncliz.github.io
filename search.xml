<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树和二叉树</title>
      <link href="/2025/07/20/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2025/07/20/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>非线性结构中的树形结构前驱个数唯一，后驱不唯一</p><p>每个树有且只有一个根结点<code>Root</code>，其余可分为n个互不相交的有限集，每个有限集本身又是一棵树，并称为根的子树</p><ul><li><strong>根节点</strong>：非空树中无前驱结点的结点</li><li>结点的<strong>度</strong>：结点拥有的子树数</li><li>树的<strong>树</strong>：树内各结点的度的最大值</li><li><strong>叶结点&#x2F;终端结点</strong>：度为零的结点，没有后驱</li><li>分支结点的度不为零，根结点之外的分支结点称为内部结点</li></ul><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>每个结点包含两个指针域，分别用来存放数据与该结点的双亲结点在数组中的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PTree</span> &#123;</span><br><span class="line">    PTNode nodes[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> r;  <span class="comment">// 根结点位置</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">// 结点个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="孩子链表"><a href="#孩子链表" class="headerlink" title="孩子链表"></a>孩子链表</h3><p>把每个结点的孩子排列成单链表，再将每个结点存入顺序表中，顺序表中每个元素的指针域指向该结点的孩子组成的链表的头指针</p><p>也可在顺序表各元素中添加双亲的位置</p><p><img src="/2025/07/20/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/haizilianbiao.png"></p><h3 id="二叉树表示法"><a href="#二叉树表示法" class="headerlink" title="二叉树表示法"></a>二叉树表示法</h3><p>用<strong>二叉链表</strong>表示树的存储结构，链表中每个结点的两个指针域分别指向该结点的第一个孩子结点和下一个兄弟结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    CSNode *child;</span><br><span class="line">    CSNode *next;</span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure><h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><p><strong>树转化为二叉树：</strong>将每个结点与左兄弟节点连线，除了第一个孩子与父结点之间的连线，除掉其余孩子与父结点间的连线</p><p><strong>二叉树转化为树：</strong>若一个结点是某个结点的左结点，则该结点的右结点以及右结点的右结点直至没有右结点，将这些结点与该结点的父结点连线，并去掉这些结点之间的连线</p><p><strong>森林转化为二叉树：</strong>先将各个树转化为二叉树，再将二叉树的根节点连线，顺时针旋转45°，这样第二棵树的根节点就变成了第一棵树根结点的右结点</p><p><strong>二叉树转化为森林：</strong>将二叉树的根节点与其右结点之间的连线去掉，使其变成孤立的二叉树，再将二叉树转化为树</p><h2 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p><strong>先根遍历：</strong>先访问根结点，再遍历各子树</p><p><strong>后根遍历：</strong>先遍历各子树，再访问根结点</p><p><strong>层次遍历：</strong></p><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><p>将森林看做由三部分组成：1.森林中第一棵树的根节点、2.森林中第一棵树的子树森林、3.森林中其他树构成的森林</p><p><strong>先序遍历：</strong>先访问1，然后先序遍历2，最后先序遍历3，相当于依次对每棵树进行<strong>先根遍历</strong></p><p><strong>中序遍历：</strong>先中序遍历2，然后访问1，最后中序遍历3，相当于依次对每棵树进行<strong>后根遍历</strong></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>每个结点最多只有两个后驱结点的树称为二叉树</p><p>二叉树的结构最简单，规律性最强，所有树都能转化为唯一对应的二叉树，且普通树若不转化为二叉树，则运算很难实现，因此解决普通树的问题时一般转化为二叉树再运算</p><p>二叉树不是树的特殊情况，是两个概念</p><p>二叉树结点的子树要区分左子树与右子树，即使只有一棵子树也要区分，因此只有两个结点的二叉树有两种状态，分别是第二个结点为左子树和第二个结点为右子树，而有两个结点的树只有一种状态</p><ul><li><strong>满二叉树</strong>：每一层结点数量都为该层最大结点数</li><li><strong>完全二叉树</strong>：除最后一层外，其余层数全满，最后一层的结点向左对齐</li></ul><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>按照满二叉树的结点层次编号，依次存放二叉树中的元素，为空则用0表示</p><p><strong>缺点</strong>：若二叉树空值较多则很浪费空间，适合用来存储满二叉树和完全二叉树</p><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    BiNode *parent;</span><br><span class="line">    BiNode *left;</span><br><span class="line">    BiNode *right;</span><br><span class="line">&#125;BiNode, *BiTree;</span><br></pre></td></tr></table></figure><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>假设 L：遍历左子树，D：遍历根节点，R：遍历右子树，规定遍历顺序为从左向右，则有三种情况，分别是DLR前序遍历，LDR中序遍历，LRD后序遍历</p><p><img src="/2025/07/20/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/bianli.png"></p><p>遍历的结果分别称为前缀表达，中缀表达，后缀表达</p><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>以下为先序排列代码，中序排列与后续排列只需变换部分位置即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bianli</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) <span class="built_in">bianli</span>(root-&gt;left);  </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) <span class="built_in">bianli</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h3><p>主要思路为先访问中结点，再将中结点存储起来，等待左结点访问完毕后访问右结点，以此循环，将各个中结点存储起来，并按照后存储的先取出的顺序访问，显然需要将结点存储在栈stack中，因此就有了以下先序遍历的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DLR</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    LinkStack p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">Push</span>(p, root);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        BiTree current = <span class="built_in">Pop</span>(p);</span><br><span class="line">        cout&lt;&lt;current-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right) <span class="built_in">Push</span>(p, current-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left) <span class="built_in">Push</span>(p, current-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先新建一个栈，将root压入栈中</li><li>进入循环，当栈空时跳出循环，中结点出栈并用<code>curent</code>保存中结点，访问中结点后依次将右结点左结点入栈，左结点后入先出，先访问左结点再访问右结点，实现中序遍历</li><li>若要实现中序遍历与后序遍历，只需更改访问结点的位置，变更代码顺序即可</li></ul><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>将每层所有结点都存入队列中，然后依次取出访问，并将其左结点与右结点在存入队列中，以此循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cengci</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">Init</span>(Q);</span><br><span class="line">    <span class="built_in">Enter</span>(Q, root);</span><br><span class="line">    <span class="keyword">while</span> (Q.front != Q.rear) &#123;</span><br><span class="line">        BiTree p = Q.front-&gt;next-&gt;data;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">Delete</span>(Q);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) <span class="built_in">Enter</span>(Q, p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) <span class="built_in">Enter</span>(Q, p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Destroy</span>(Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先将根结点存入队列中，进入循环，循环条件为队列不为空，用p表示根结点，访问根结点后取出，接着将左结点与右结点存入队列末尾</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>已知二叉树的先序和中序序列，构造出相应的二叉树</p><p>先序：A  B  C  D  E  F  G  H  I  J</p><p>中序：C  D  B  F  E  A  I  H  G  J  </p><p>由先序遍历可知，A为根结点的值，结合中序序列可推测出CDBFE为左子树，IHGJ为右子树；再看先序序列A之后是B，因此B为左子树的根节点，可得出CD为左子树的左子树，FE为左子树的右子树；再看先序序列B之后的C，多次重复即可得出结果</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="计算深度"><a href="#计算深度" class="headerlink" title="计算深度"></a>计算深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">Depth</span>(root-&gt;left), <span class="built_in">Depth</span>(root-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算结点数"><a href="#计算结点数" class="headerlink" title="计算结点数"></a>计算结点数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Number</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">Number</span>(root-&gt;left) + <span class="built_in">Number</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算叶结点数"><a href="#计算叶结点数" class="headerlink" title="计算叶结点数"></a>计算叶结点数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LeafNum</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LeafNum</span>(root-&gt;left) + <span class="built_in">LeafNum</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>利用二叉树中的空指针域，如果某个结点的左结点为空，则将左结点指针域<strong>改为指向其前驱</strong>，若右结点为空，则<strong>改为指向其后继</strong>，这种改变指向的指针称为<strong>线索</strong>，加上线索的二叉树称为<strong>线索二叉树</strong>，对二叉树按某种遍历次序使其变为线索二叉树的过程叫做<strong>线索化</strong></p><p>为区分<code>left</code>与<code>right</code>指向孩子还是指向前驱或后继，在二叉链表的每个节点中增设两个标致域<code>ltag</code>和<code>rtag</code>，当值为0时指向孩子，值为1时指向前驱或后继</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p><strong>树的路径长度</strong>指树的根结点到每个结点的路径长度之和</p><p>结点数相同的二叉树中，<strong>完全二叉树</strong>是路径长度最短的二叉树，但路径最短的二叉树不一定是完全二叉树</p><p><strong>权：</strong>将树中结点赋给一个有着某种含义的数值，则这个值称为该结点的权</p><p><strong>结点的带权路径长度：</strong>从根结点到该结点之间的路径长度与该结点的权的乘积</p><p><strong>树的带权路径长度：</strong>树中<strong>所有叶结点</strong>的带权路径长度之和</p><ul><li><strong>哈夫曼树：</strong>最优二叉树，即<strong>带权路径长度最短</strong>的二叉树</li></ul><h3 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h3><ol><li>根据n个给定的权值，构成n棵深度为零的二叉树的森林</li><li>在森林中选取两个权值最小的二叉树作为新二叉树的左右子树，新二叉树的权值即为这两棵二叉树的权值之和</li><li>在森林中删除这两棵用到的二叉树，再将新二叉树加入森林中</li><li>重复(2)(3)直至森林中只剩一棵树，这棵树即为哈夫曼树</li></ol><ul><li>哈夫曼树的结点度数只能为0或2，不能为1</li><li>包含n个叶结点的哈夫曼树共有2n-1个结点</li></ul><h3 id="构造算法的实现"><a href="#构造算法的实现" class="headerlink" title="构造算法的实现"></a>构造算法的实现</h3><p>采用顺序存储结构，一维结构数组，为方便处理，数组的第0位不使用，从第一位开始</p><p>先初始化哈夫曼树，为前n个结点的权赋值并将其他数据赋为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(HuffmanTree tree, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">+1</span>; i &lt;= <span class="number">2</span>*n; i++) &#123;</span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="type">int</span> s1 = <span class="number">-1</span>, s2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[j].parent == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1==<span class="number">-1</span> || tree[s1].weight &gt; tree[j].weight) &#123;</span><br><span class="line">                    s2 = s1;</span><br><span class="line">                    s1 = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s2==<span class="number">-1</span> || (tree[s2].weight &gt; tree[j].weight &amp;&amp; s1 != j)) &#123; <span class="comment">// (2)</span></span><br><span class="line">                    s2 = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.</span></span><br><span class="line">        tree[i].weight = tree[s1].weight + tree[s2].weight;</span><br><span class="line">        tree[i].left = s1;</span><br><span class="line">        tree[i].right = s2;</span><br><span class="line">        tree[s1].parent = i;</span><br><span class="line">        tree[s2].parent = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造哈夫曼树的过程就是逐个为后n-1个元素的权进行赋值，当最后一个元素得到权，就意味着哈夫曼树构造成功，因此需要一个从n+1开始2n结束的循环</li><li>其中步骤1.表示在所有没有父结点的结点中找出最小的两个结点s1、s2，步骤2.表示为第i位元素的数据进行赋值，并添加s1、s2所代表的结点的父结点，用来表示这两个结点已合并</li><li>(1)求最小值与次小值，LeetCode第414题官方题解方法三，注意赋值时的顺序</li><li>(2)需添加<code>s1 != j</code>来防止s1s2指向同一个结点</li></ul><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>传递字符时，若使用等长的编码方式会浪费空间，因此可以使用不等长的编码方式，但这样要解码时就容易出现重码问题</p><p>因此要解决重码问题，则必须<strong>使任一字符的编码都不是另一个字符的编码的前缀</strong>，哈夫曼编码即可保证是前缀编码</p><p>哈夫曼编码是以每个字符出现的概率&#x2F;次数作为权重，构造哈夫曼树，再用左孩子代表0，右孩子代表1，得到各个字符的编码</p><p><img src="/2025/07/20/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/bianma.png"></p><ul><li>图中从根结点到每个字符的路径上都不会遇到其他字符，所以每个叶结点的编码都不是其他叶结点编码的前缀，因此能够保证是前缀编码</li><li>哈夫曼树<strong>带权路径长度最短</strong>的性质保证了字符编码的总长最短</li></ul><h3 id="构造哈夫曼编码"><a href="#构造哈夫曼编码" class="headerlink" title="构造哈夫曼编码"></a>构造哈夫曼编码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function">string* <span class="title">CreateHuffmanCode</span><span class="params">(HuffmanTree tree, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    string *codes = <span class="keyword">new</span> string[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        string cd = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> j = i, p = tree[i].parent;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[p].left==j) cd += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cd +=  <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            j = p;</span><br><span class="line">            p = tree[p].parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(cd.<span class="built_in">begin</span>(), cd.<span class="built_in">end</span>());</span><br><span class="line">        codes[i] = cd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> codes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从叶结点向根结点回溯，若子结点是父结点的左结点则记为0，右结点记为1，将编码暂时存储在字符串中，最后反转再赋值给字符串数组</li><li>使用字符串临时存放编码，优点是不用考虑越界问题，且最后不用进行转换</li><li><code>reverse(a, b)</code>表示反转从a到b区间内的字符串，<code>cd.begin()``cd.end()</code>分别表示字符串cd的开始和末尾，<code>#include &lt;algorithm&gt;</code>是使用<code>reverse</code>时所需的头文件</li></ul><h3 id="文件的编码与解码"><a href="#文件的编码与解码" class="headerlink" title="文件的编码与解码"></a>文件的编码与解码</h3><ul><li><strong>编码：</strong>获取各字符及其权值，构造哈夫曼树，进行哈夫曼编码，得到各字符的哈夫曼编码</li><li><strong>解码：</strong>构造哈夫曼树，得到各字符的哈夫曼编码，对文本进行解码得到原码报文</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串、数组、广义表</title>
      <link href="/2025/07/03/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
      <url>/2025/07/03/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p>​与栈和队列相似，串是<strong>内容受限</strong>的线性表，串的元素只能是<strong>字符</strong></p><ul><li>串中任意个连续字符组成的子序列称为该串的子串，真子串指不包含自身的所有子串</li></ul><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLENGTH 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SString</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[MAXLENGTH + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><ul><li>加一使位序与下标相等，<code>data</code>中第一个元素闲置不用，便于后续的计算</li></ul><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Chunk</span> &#123;</span><br><span class="line"><span class="type">char</span> data[CHUNKSIZE];</span><br><span class="line">Chunk *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struck LString &#123;</span><br><span class="line">Chunk *head, *tail;  <span class="comment">// 串的头指针与尾指针</span></span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><ul><li>使用<strong>块链结构</strong>，一块的大小为<code>CHUNKSIZE</code>，以此来提高存储密度</li></ul><h2 id="串的模式匹配——KMP算法"><a href="#串的模式匹配——KMP算法" class="headerlink" title="串的模式匹配——KMP算法"></a>串的模式匹配——KMP算法</h2><p>确定主串中所含子串第一次出现的位置</p><p>详见【最浅显易懂的 KMP 算法讲解】 <a href="https://www.bilibili.com/video/BV1AY4y157yL/?share_source=copy_web&vd_source=fbe4b0e6c9f599f2e20ea27ac67af734">https://www.bilibili.com/video/BV1AY4y157yL/?share_source=copy_web&amp;vd_source=fbe4b0e6c9f599f2e20ea27ac67af734</a></p><p>首先根据子串得出一个<code>next</code>数组，用来表示<strong>当匹配进行到该处时应该跳过子串前面的多少个字符</strong>，主串的i永远不递减</p><p>KMP算法思路是，当发现某个字符不匹配时，根据已经知道之前遍历过的字符来避免暴力算法中的回退步骤</p><h3 id="已知next"><a href="#已知next" class="headerlink" title="已知next"></a>已知next</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="type">char</span> main[], <span class="type">char</span> child[],<span class="type">int</span> next[], <span class="type">int</span> slen, <span class="type">int</span> clen)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; slen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (main[i] == child[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == clen) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当匹配时，i和j都加一</p></li><li><p>当匹配失败时，若j为零则<code>i++</code>；若j不为零，会根据最后一个匹配的字符的<code>next</code>值即<code>next[j - 1]</code>来作为j的值，此时i不加一</p></li><li><p>判断是否子串完全匹配成功，因为如果成功一定会执行子串最后一个字符匹配成功的结果，导致<code>j++</code>，此时<code>j == clen</code></p></li><li><p>最后<code>return</code>的值是子串的第一位在主串中的位置</p></li></ul><h3 id="getNext"><a href="#getNext" class="headerlink" title="getNext"></a>getNext</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">char</span> ch[], <span class="type">int</span> len, <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> prefix_len = <span class="number">0</span>;  <span class="comment">// 当前共同前后缀的长度,即next[j-1]</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[i] == ch[prefix_len]) &#123;</span><br><span class="line">            prefix_len++;</span><br><span class="line">            next[i] = prefix_len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prefix_len == <span class="number">0</span>) &#123;</span><br><span class="line">                next[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                prefix_len = next[prefix_len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从<code>i = 1</code>开始，与第<code>prefix_len</code>位比对，初始为第0位</li><li>若相同则<code>i</code>与<code>prefix_len</code>均加一，并将<code>prefix_len</code>的值赋给<code>next[i]</code></li><li>不相同则判断next数组上一个元素的值即<code>prefix_len</code>，为零则给<code>next[i]</code>赋值为零</li><li>若<code>prefix_len</code>不为零，以<code>ABACABAB</code>为例，进行至最后的<code>B</code>时，此时<code>prefix_len = 3</code>，最后的<code>ABA</code>与子串开头是相同的，因此前缀也相同，将<code>prefix_len</code>回溯为<code>next[prefix_len - 1]</code>，此时i不变，继续进行循环</li></ul><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;acbabacababa&quot;</span>;</span><br><span class="line">    <span class="type">int</span> slen = <span class="built_in">sizeof</span>(s);</span><br><span class="line">    <span class="type">int</span> clen = <span class="built_in">sizeof</span>(ch);</span><br><span class="line">    <span class="type">int</span>* next = <span class="keyword">new</span> <span class="type">int</span>[clen];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getNext</span>(ch, clen, next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clen; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, next[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> place = <span class="built_in">KmpSearch</span>(s, ch, next, slen, clen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;&amp; %d&quot;</span>, place);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] next;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果为<code>0 0 1 0 1 2 3 2 &amp;&amp; 4</code></li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>按照一定格式排列起来的，具有相同类型的数据元素的集合</p><p>由于数组<strong>长度固定</strong>且一般<strong>不做插入和删除操作</strong>，因此一般都用顺序存储来表示</p><h3 id="顺序存储-1"><a href="#顺序存储-1" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>数组可以是多维的，但存储数组的内存单元是一维的，因此在存储之前需要将多维关系映射到一维关系，这样就产生了两种存储二维数组的方法，分别为<strong>以行序为主序</strong>和<strong>以列序为主序</strong></p><h3 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h3><p><strong>值相同的元素很多且呈某种规律分布</strong>或<strong>零元素多</strong>的矩阵不适宜常规存储，要进行压缩存储</p><p><strong>压缩存储</strong>即为多个相同的非零元素只分配一个存储空间，对零元素不分配空间</p><p>对存在大量元素为零的矩阵(稀疏矩阵)的存储可以用三元组存储，格式为<code>(i, j, aij)</code>，得出来的三元组顺序表中第零位用来存储总行数，总列数与元素个数</p><p>对于稀疏矩阵也有相关的链式存储结构——<strong>十字链表</strong></p><p>在十字链表中，每一个非零元素用节点表示，结点除了row，col，value外还有两个域right，down，分别用来链接该元素同一行中下一个非零元素与同列中下一个非零元素</p><p>矩阵的行数与列数分别就是需要的行头指针与列头指针的数量，通过各个行头指针与列头指针将元素链接起来便于查找(真麻烦啊)</p><p><img src="/2025/07/03/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%B9%BF%E4%B9%89%E8%A1%A8/shizilianbiao.png"></p><h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><p>广义表的每个元素是一个原子，或是一个广义表。广义表一般记为<code>LS = (a1, ..., an)</code></p><ul><li>表头：若LS非空，则第一个元素<code>a1</code>就是表头</li><li>表尾：除表头之外的其他元素组成的表，<code>(a2, ..., an)</code>是表尾，表尾不是最后一个元素，而是一个子表</li></ul><p>广义表是线性表的推广，线性表是广义表的特例</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX</title>
      <link href="/2025/06/26/AJAX/"/>
      <url>/2025/06/26/AJAX/</url>
      
        <content type="html"><![CDATA[<h1 id="AJAX原理—XMLHttpRequest"><a href="#AJAX原理—XMLHttpRequest" class="headerlink" title="AJAX原理—XMLHttpRequest"></a>AJAX原理—XMLHttpRequest</h1><p>​<code>XMLHttpRequest</code>(XHR)对象用于与服务器交互，<code>axios</code>实际上就是对XHR的封装</p><h2 id="使用XMLHttpRequest"><a href="#使用XMLHttpRequest" class="headerlink" title="使用XMLHttpRequest"></a>使用XMLHttpRequest</h2><ol><li>创建XHR对象</li><li>配置请求方法与URL</li><li>监听<code>loadend</code>加载完毕事件，接收响应结果</li><li>发送请求</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://localhost:3000/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>); <span class="comment">// 设置请求头，指示消息体类型为JSON</span></span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 若类型为GET则send后不能接数据</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h3><p>格式为<code>http://xxx.com?参数1=值1&amp;参数2=值2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&#x27;http://localhost:3000?name=abc&amp;age=18&#x27;</span>)</span><br></pre></td></tr></table></figure><p>服务端(node.js的express)收到后可通过<code>req.query</code>取出</p><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>也叫body参数，可通过post请求发送，发送请求时最好设置请求头声明携带的数据类型，如<code>Content-Type: application/json</code></p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>​Promise表示管理一个<strong>异步操作</strong>最终状态和结果值的对象</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>.then</code>表示执行成功的回调函数，<code>.catch</code>表示执行失败的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 执行操作</span></span><br><span class="line">    <span class="comment">// resolve(值)表示成功，执行下一个then</span></span><br><span class="line">    <span class="comment">// reject(值)表示失败，执行catch</span></span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h2><ul><li><code>pending</code>待定，在promise管理的异步任务执行完毕之前的状态</li><li><code>fulfilled</code>已兑现，执行完<code>resolve()</code>后的状态，将resolve的参数传递给then并执行回调函数</li><li><code>rejected</code>已拒绝，执行完<code>reject()</code>后的状态，将reject的参数传递给catch并执行回调函数</li></ul><p>Promise的状态只能改变一次，一旦被兑现&#x2F;拒绝就无法改变</p><h1 id="封装简易axios"><a href="#封装简易axios" class="headerlink" title="封装简易axios"></a>封装简易axios</h1><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>axios的.then和.catch来自Promise，因此只需在函数里return一个Promise即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myAxios</span>(<span class="params">config</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">        xhr.<span class="title function_">open</span>(config.<span class="property">method</span> || <span class="string">&#x27;GET&#x27;</span>,config.<span class="property">url</span>)</span><br><span class="line">        xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt;<span class="number">300</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">response</span>))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>&#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(xhr.<span class="property">response</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(xhr.<span class="property">response</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        xhr.<span class="title function_">send</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不传入请求方法则默认为<code>GET</code>，使用逻辑中断<code>||</code>实现</li><li>通过响应状态码判断请求是否发送成功，进而确定Promise的状态，并将response传过去</li><li>失败时一般创建<code>Error</code>对象来存入错误信息</li><li>使用<code>try-catch</code>来判断服务端传输来的数据是否是JSON，是则解析为对象，便于前端使用</li></ul><p>使用方法有局限性，无法传入查询字符串</p><h2 id="实现传入查询字符串"><a href="#实现传入查询字符串" class="headerlink" title="实现传入查询字符串"></a>实现传入查询字符串</h2><p>在<code>open</code>前进行判断，因为查询字符串需要拼接在地址中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myAxios</span>(<span class="params">config</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">        <span class="keyword">if</span>(config.<span class="property">params</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> queryString = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(config.<span class="property">params</span>).<span class="title function_">toString</span>()</span><br><span class="line">            config.<span class="property">url</span> += <span class="string">`?<span class="subst">$&#123;queryString&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        xhr.<span class="title function_">open</span>(config.<span class="property">method</span> || <span class="string">&#x27;GET&#x27;</span>,config.<span class="property">url</span>)</span><br><span class="line">        ...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>URLSearchParams</code>是浏览器提供的构造函数，传入对象可将其转化为查询字符串的格式，再使用<code>toString</code>将其转换成字符串的形式，最后将其与url拼接起来</li></ul><h2 id="实现携带请求体数据"><a href="#实现携带请求体数据" class="headerlink" title="实现携带请求体数据"></a>实现携带请求体数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> data = config.<span class="property">data</span> ? <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(config.<span class="property">data</span>) : <span class="literal">undefined</span></span><br><span class="line">xhr.<span class="title function_">send</span>(data)</span><br></pre></td></tr></table></figure><ul><li>在发送请求前设置请求头</li><li>使用逻辑中断<code>||</code>获取<code>data</code>数据</li><li>若用<code>const data = JSON.stringify(config.data) || undefined</code>，当<code>data</code>不存在时会报错</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">myAxios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:8000/&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6模块化规范</title>
      <link href="/2025/06/25/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/"/>
      <url>/2025/06/25/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="Node中运行ES6模块"><a href="#Node中运行ES6模块" class="headerlink" title="Node中运行ES6模块"></a>Node中运行ES6模块</h2><ol><li><p>将所有JS文件后缀改为.mjs</p></li><li><p>在package.json(没有就新建)中声明<code>type</code>为<code>module</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="暴露"><a href="#暴露" class="headerlink" title="暴露"></a>暴露</h2><h3 id="分别暴露"><a href="#分别暴露" class="headerlink" title="分别暴露"></a>分别暴露</h3><p>在想要暴露的数据前加上<code>export</code>关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;666&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sayhi</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统一暴露"><a href="#统一暴露" class="headerlink" title="统一暴露"></a>统一暴露</h3><p>在代码的最后加上<strong>类似对象结构</strong>的语句<code>expost &#123;&#125;</code>，不能写成<code>name: name</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;666&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayhi</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;name, sayhi&#125;</span><br></pre></td></tr></table></figure><h3 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h3><p>在代码最后使用<code>export default</code>关键字后接对象作为默认导出</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>当js文件使用了ES6模块，浏览器引入时就需要修改<code>type</code>为<code>module</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="全部引入"><a href="#全部引入" class="headerlink" title="全部引入"></a>全部引入</h3><p><code>* as</code>后接命名，适用于所有方法的暴露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> abc <span class="keyword">from</span> <span class="string">&#x27;./app.js&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="命名引入"><a href="#命名引入" class="headerlink" title="命名引入"></a>命名引入</h3><p>当使用分别暴露与统一暴露时才可使用命名引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;name&#125; <span class="keyword">from</span> <span class="string">&#x27;./app.js&#x27;</span></span><br></pre></td></tr></table></figure><p>若想为<code>name</code>重新命名可添加<code>as</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;name <span class="keyword">as</span> name1&#125; <span class="keyword">from</span> <span class="string">&#x27;./app.js&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="默认引入"><a href="#默认引入" class="headerlink" title="默认引入"></a>默认引入</h3><p>只有使用默认暴露时才可使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc <span class="keyword">from</span> <span class="string">&#x27;./app.js&#x27;</span></span><br></pre></td></tr></table></figure><p>abc即为默认导出的对象</p><p><code>import</code>可以不接受任何数据，表示执行该模块代码</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>引入的数据与暴露的数据公用一块内存空间，因此暴露的数据一般设为const</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端HTML与CSS</title>
      <link href="/2025/06/23/%E7%A7%BB%E5%8A%A8%E7%AB%AFHTML%E4%B8%8ECSS/"/>
      <url>/2025/06/23/%E7%A7%BB%E5%8A%A8%E7%AB%AFHTML%E4%B8%8ECSS/</url>
      
        <content type="html"><![CDATA[<h2 id="标签"><a href="#标签" class="headerlink" title="&lt;meta&gt;标签"></a><code>&lt;meta&gt;</code>标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>width=device-width</code>，设置视口宽度为设备宽度</li><li><code>user-scalable=no</code>，是否允许用户缩放</li><li><code>initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0</code>，最初缩放比，最大缩放比，最小缩放比</li></ul><h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><h3 id="物理像素-物理像素比"><a href="#物理像素-物理像素比" class="headerlink" title="物理像素&amp;物理像素比"></a>物理像素&amp;物理像素比</h3><ul><li>物理像素指屏幕显示的最小颗粒，是物理真实存在的</li><li>在PC端页面中，1px等于1物理像素，移动端不一定</li><li>1px能显示的物理像素点的个数，称为物理像素比</li></ul><h2 id="流式布局-百分比布局"><a href="#流式布局-百分比布局" class="headerlink" title="流式布局(百分比布局)"></a>流式布局(百分比布局)</h2><p>通过将盒子的宽度设置成百分比来根据屏幕的宽度进行伸缩，不受固定像素的限制。</p><ul><li><code>max-width,max-heighgt,min-width,min-height</code>，最大宽度，高度，最小宽度，高度</li><li><code>1vw,1vh</code>表示视口宽度&#x2F;高度的百分之一</li></ul><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>详见<a href="/2025/06/08/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%B8%8EFlex-Grid%E5%B8%83%E5%B1%80/">Flex布局</a></p><h2 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h2><p><code>1em</code>等于当前元素的<code>font-size</code>，<code>1rem</code>(root em)等于根元素的<code>font-size</code>，是相对于html元素的字体大小</p><p>通过rem修改所有盒子的宽度和高度，实现整体的控制</p><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询(Media Query)是CSS3的新语法</p><ul><li><code>@media</code>可以针对屏幕尺寸设置不同的样式</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 仅表示格式</span><br><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span>|<span class="keyword">not</span>|<span class="keyword">only</span> (media feature)&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mediatype</code>可为<code>all</code>，用于所有设备，<code>print</code>用于打印和打印预览，<code>screen</code>用于屏幕</li><li><code>and</code>可将多个媒体特性连接在一起，<code>not</code>排除某个媒体类型，<code>only</code>指定某个特定的媒体类型，可以省略</li><li><code>media feature</code>媒体特性，例如<code>width</code>、<code>min-width</code>、<code>max-width</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在宽度小于<span class="number">800px</span>的屏幕上，<span class="selector-tag">body</span>的背景颜色为skyblue</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">800px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="媒体查询-rem实现元素动态变化"><a href="#媒体查询-rem实现元素动态变化" class="headerlink" title="媒体查询+rem实现元素动态变化"></a>媒体查询+rem实现元素动态变化</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">800px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">3vw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">5vw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="媒体查询引入资源"><a href="#媒体查询引入资源" class="headerlink" title="媒体查询引入资源"></a>媒体查询引入资源</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style320.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (min-width:320px)&quot;</span>&gt;</span>  // 屏幕320px以上用style320</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style640.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (min-width:640px)&quot;</span>&gt;</span>  // 屏幕640px以上用style640</span><br></pre></td></tr></table></figure><h1 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h1><p>通过媒体查询实现，针对不同宽度的设备进行布局和样式的设置，一般分为四个档位</p><ul><li>手机，尺寸&lt;768px</li><li>平板，768&lt;&#x3D;尺寸&lt;992px</li><li>桌面显示器，992&lt;&#x3D;尺寸&lt;1200px</li><li>宽屏设备，尺寸&gt;&#x3D;1200px</li></ul><p>响应式需要一个父级作为布局容器来配合子级元素实现变化，原理为在不同屏幕下通过媒体查询来改变布局容器的大小，在改变子元素的大小与排列方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">767px</span>) &#123;  </span><br><span class="line">       <span class="selector-class">.container</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100%</span>; </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;  </span><br><span class="line">       <span class="selector-class">.container</span>&#123;       </span><br><span class="line">           <span class="attribute">width</span>: <span class="number">750px</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">992px</span>) &#123;  </span><br><span class="line">       <span class="selector-class">.container</span>&#123;  </span><br><span class="line">           <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1200px</span>) &#123;  </span><br><span class="line">       <span class="selector-class">.container</span>&#123; </span><br><span class="line">           <span class="attribute">width</span>: <span class="number">1170px</span>;   </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2025/06/20/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2025/06/20/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>​栈和队列都是线性表，但是插入和删除位置被限定了</p><h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h1><p>​插入和删除操作只能在<strong>表尾</strong>进行，<strong>先进后出</strong>，简称<code>LIFO</code>结构</p><ul><li>表尾<code>an</code>称为<strong>栈顶</strong><code>Top</code>，表头<code>a1</code>称为<strong>栈底</strong><code>Base</code></li><li>插入元素到栈顶的操作称为<strong>入栈</strong><code>PUSH</code>，删除栈顶最后一个元素称为<strong>出栈</strong><code>POP</code></li><li>有顺序栈和链栈两种方式，顺序栈更常见</li><li>为方便操作，<code>top</code>指针一般指向栈顶上一个的元素，此时<code>top - base = size</code>，初始时<code>top = base</code></li></ul><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">    <span class="type">int</span> *top;</span><br><span class="line">    <span class="type">int</span> *base;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h3><p><code>top = base</code>说明是空栈，<code>top - base = stackbase</code>说明栈满</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    S.stacksize = <span class="number">100</span>;  <span class="comment">// 栈的最大长度</span></span><br><span class="line">    S.base = <span class="keyword">new</span> <span class="type">int</span>[stacksize];</span><br><span class="line">    S.top = S.base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h3><p>进栈时会覆盖原来的值，因此没必要删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cleaer</span><span class="params">(SqStack &amp; S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.base) S.top = S.base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Destory"><a href="#Destory" class="headerlink" title="Destory"></a>Destory</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Destory</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> S.base;</span><br><span class="line">    S.stacksize = <span class="number">0</span>;</span><br><span class="line">    S.base = <span class="literal">NULL</span>;</span><br><span class="line">    S.top = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base != S.stacksize) &#123;  <span class="comment">// 判断是否栈满</span></span><br><span class="line">        *S.top = e;  <span class="comment">// 将元素e压入栈顶</span></span><br><span class="line">        S.top++;  <span class="comment">// 栈顶指针加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top != S.base) &#123;</span><br><span class="line">        S.top--;</span><br><span class="line">        <span class="keyword">return</span> *S.top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><ul><li>链栈中<code>next</code>指向的是前驱而不是后继，即<code>an-&gt;next = an-1</code></li><li>不需要头结点</li><li>链表的头指针就是栈顶</li></ul><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    StackNode *next;</span><br><span class="line">&#125;StackNode, *LinkStack;</span><br></pre></td></tr></table></figure><h3 id="Push-1"><a href="#Push-1" class="headerlink" title="Push"></a>Push</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(LinkStack &amp;S, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    StackNode *p = <span class="keyword">new</span> LinkStack;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S;  <span class="comment">// p称为栈顶</span></span><br><span class="line">    S = p;  <span class="comment">// 修改栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pop-1"><a href="#Pop-1" class="headerlink" title="Pop"></a>Pop</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pop</span><span class="params">(LinkStack &amp;S)</span> </span>&#123;</span><br><span class="line">    LinkStack p = S;</span><br><span class="line">    S = S-&gt;next;  <span class="comment">// 栈顶指针下移一位</span></span><br><span class="line">    <span class="type">int</span> e = p-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h1><p>​插入只能插在<strong>表尾</strong>，删除只能删除<strong>表头元素</strong>，<strong>先进先出</strong>，简称<code>FIFO</code>结构</p><ul><li>表尾称为队尾，表头称为队头</li><li>有顺序队和链队两种方式，循环顺序队列更常见</li><li>初始时<code>front = rear = 0</code>，<code>rear</code>一般指向队尾后一位</li></ul><h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><ul><li>当<code>rear = MAXQSIZE</code>时发生溢出，当<code>front !=0, rear = MAXQSIZE</code>时发生假溢出，即队列中还有空间</li><li>使用<strong>循环队列</strong>来解决假溢出，利用取模运算<code>%</code></li><li>循环队列队空和对满时均有<code>front = rear</code>，如何判断队列已满：设置一个标志来区别队空与队满；另设一个变量记录元素个数；少用一个元素空间，这样当<code>front = (rear + 1) % MAXSIZE</code>时队列已满</li></ul><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p>采用少用一个空间的方法来区分队满和队空，此时队列长度为<code>(Q.rear + MAXSIZE - Q.front) % MAXSIZE</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> *base;</span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 队头指针</span></span><br><span class="line">    <span class="type">int</span> rear;  <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><h3 id="Init-1"><a href="#Init-1" class="headerlink" title="Init"></a>Init</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.base = <span class="keyword">new</span> <span class="type">int</span>[MAXSIZE];  <span class="comment">// 因为Q不是指针，所以不用-&gt;而用.</span></span><br><span class="line">    Q.front = <span class="number">0</span>;</span><br><span class="line">    Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Enter"><a href="#Enter" class="headerlink" title="Enter"></a>Enter</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Enter</span><span class="params">(SqQueue &amp;Q, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front) <span class="keyword">return</span>;  <span class="comment">// 判断是否队满</span></span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式队列的节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    QNode *next;</span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h3 id="Init-2"><a href="#Init-2" class="headerlink" title="Init"></a>Init</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.front = <span class="keyword">new</span> <span class="built_in">QNode</span>();</span><br><span class="line">    Q.rear = Q.front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Enter-1"><a href="#Enter-1" class="headerlink" title="Enter"></a>Enter</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Enter</span><span class="params">(LinkQueue &amp;Q, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    QNode *p = <span class="keyword">new</span> <span class="built_in">QNode</span>();</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    Q.front-&gt;data++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>如果被删除的元素就是最后一个元素(即<code>Q.rear == p</code>)，则要将尾指针移回头指针(<code>Q.rear = Q.front</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span>;</span><br><span class="line">    QNode *p = Q.front-&gt;next; <span class="comment">// 使p指向要删除的元素</span></span><br><span class="line">    Q.front-&gt;next = p-&gt;next;  <span class="comment">// 使front的next指向第二个元素</span></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) Q.rear = Q.front;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    Q.front-&gt;data--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Destroy"><a href="#Destroy" class="headerlink" title="Destroy"></a>Destroy</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q.front) &#123;</span><br><span class="line">        QNode *p =Q.front;</span><br><span class="line">        Q.front = Q.front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表与链表</title>
      <link href="/2025/06/17/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/06/17/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><p>​<strong>顺序线性表</strong>是指用一组<strong>地址连续的存储单元</strong>一次存储数据元素的线性结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">// 长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h3 id="引用类型做参数传地址"><a href="#引用类型做参数传地址" class="headerlink" title="引用类型做参数传地址"></a>引用类型做参数传地址</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> &amp;j = i;</span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">    cont&lt;&lt;<span class="string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;j=&quot;</span>&lt;&lt;j;  <span class="comment">// i=2 j=2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事例中j是i的引用，代表i的一个替代名，i值改变时j也跟着改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;m, <span class="type">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = m;</span><br><span class="line">    m = n;</span><br><span class="line">    n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl; <span class="comment">// 2 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与传递指针的效果一样</li><li>引用类型做形参，在内存中并没有产生实参的副本，直接对实参进行操作，因此使用引用传递参数的时间空间效率都很好</li></ul><h2 id="主要操作的实现"><a href="#主要操作的实现" class="headerlink" title="主要操作的实现"></a>主要操作的实现</h2><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e为要插入的值，n为要插入的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(SqList &amp;L, <span class="type">int</span> e, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> || n &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=L.length<span class="number">-1</span>; i&gt;=n; i--) &#123;</span><br><span class="line">            L.data[i<span class="number">+1</span>] = L.data[i];  <span class="comment">// 插入位置及之后的元素右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        L.data[n] = e;  <span class="comment">// 将新元素e放入第i个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n为删除的序列号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> || n &gt;= L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n; i&lt;L.length<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        L.data[i] = L.data[i<span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>存储密度大</li><li>可以随机存取表中任一元素</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>在插入、删除时需要移动大量元素</li><li>浪费存储空间</li><li>属于静态存储形式，数据元素的个数不能自由扩充</li></ul><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>​<strong>链表</strong>用一组<strong>物理位置任意</strong>的存储单元来存放线性表，链表中逻辑次序与物理次序不一定相同。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​<strong>链表</strong>由若干个<strong>结点</strong>构成，每一个结点包括<strong>数据域</strong>与<strong>指针域</strong>，数据域存储数据本身，指针域存储下一个元素的地址，用来表示逻辑次序。只要记录第一个元素的指针(<strong>头指针</strong>)即可找到其他元素的存储位置</p><ul><li><strong>单链表：</strong>结点只有一个指针域的链表</li><li><strong>双链表：</strong>结点有两个指针域的链表，一个存储前驱的地址，一个存储后继的地址</li><li><strong>循环链表：</strong>首尾相接的链表为循环链表</li></ul><h3 id="头结点与首元结点"><a href="#头结点与首元结点" class="headerlink" title="头结点与首元结点"></a>头结点与首元结点</h3><ul><li>头结点是在链表的首元结点之前附设的一个结点</li><li>首元结点为存储第一个元素的结点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Lnode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Lnode *next;</span><br><span class="line">&#125;Lnode, *LinkList;  <span class="comment">// LinkList为指针类型的结构体的别名 </span></span><br></pre></td></tr></table></figure><p>定义链表L通常用<code>LinkList L;</code>，定义结点通常用<code>Lnode *p;</code></p><h2 id="对链表的操作"><a href="#对链表的操作" class="headerlink" title="对链表的操作"></a>对链表的操作</h2><h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h3><p>链表初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> Lnode;  <span class="comment">// 从内存中分配一个节点空间，用头指针L指向这个节点</span></span><br><span class="line">    L-&gt;data = <span class="number">0</span>;  <span class="comment">// 头结点的data用来存放链表的长度</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Destory"><a href="#Destory" class="headerlink" title="Destory"></a>Destory</h3><p>销毁链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (L) &#123;</span><br><span class="line">        LinkList p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GetData"><a href="#GetData" class="headerlink" title="GetData"></a>GetData</h3><p>获取第n位的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    Lnode *p = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><p>查找链表中数据为e的结点的位置并返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search</span><span class="params">(LinkList &amp;L, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    Lnode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=L-&gt;data; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Insert-1"><a href="#Insert-1" class="headerlink" title="Insert"></a>Insert</h3><p>在链表的第n位插入新元素e</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; L-&gt;data + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Lnode *p = L;  </span><br><span class="line">    Lnode *newdata = <span class="keyword">new</span> Lnode;</span><br><span class="line">    newdata-&gt;data = e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        p = p-&gt;next;  <span class="comment">// 用p来指向第n-1位的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lnode *q = p-&gt;next;  <span class="comment">// 用q指向原来第n位的元素</span></span><br><span class="line">    p-&gt;next = newdata;  <span class="comment">// 使第n-1位元素的后继为newdata</span></span><br><span class="line">    newdata-&gt;next = q;  <span class="comment">// 使原来第n位元素的前驱为newdata</span></span><br><span class="line">    L-&gt;data++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete-1"><a href="#Delete-1" class="headerlink" title="Delete"></a>Delete</h3><p>删除链表第n位的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; L-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Lnode *p = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        p = p-&gt;next;  <span class="comment">// 使p指向第n-1位的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lnode *q = p-&gt;next;  <span class="comment">// 使p指向第n位的元素</span></span><br><span class="line">    p-&gt;next = q-&gt;next;  <span class="comment">// 使原来第n+1位的元素成为第n-1位的后继</span></span><br><span class="line">    <span class="keyword">delete</span> q;  <span class="comment">// 释放内存</span></span><br><span class="line">    L-&gt;data--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h3><p>将新建的结点接在头结点的后面 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> Lnode;</span><br><span class="line">    L-&gt;data = n;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Lnode *p = <span class="keyword">new</span> Lnode;  <span class="comment">// 生成新节点</span></span><br><span class="line">        cin &gt;&gt; p-&gt;data;  <span class="comment">// 输入元素值,等于scanf(&quot;%d&quot;, &amp;p-&gt;data);</span></span><br><span class="line">        p-&gt;next = L-&gt;next;  <span class="comment">// 插入到表头</span></span><br><span class="line">        L-&gt;next = p;  <span class="comment">// 插入到表头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h3><p>将新建的结点插在尾指针后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> Lnode;</span><br><span class="line">    L-&gt;data = n;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Lnode *r = L;  <span class="comment">// 创建尾指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Lnode *p = <span class="keyword">new</span> Lnode;  <span class="comment">// 生成新结点</span></span><br><span class="line">        cin &gt;&gt; p-&gt;data;</span><br><span class="line">        r-&gt;next = p;  <span class="comment">// 插入到尾指针后</span></span><br><span class="line">        r = p;  <span class="comment">// 更新尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>​链表中最后一个结点的<code>next</code>指向头结点，由于表的操作通常是在首尾位置上执行，若用头指针表示单循环链表，查找最后一位元素时需要遍历整个链表，较为麻烦，但如果使用尾指针表示单循环链表，第一位元素可表示为<code>R-&gt;next-&gt;next</code>，最后一位为<code>R</code>，更为方便</p><h3 id="循环链表的合并"><a href="#循环链表的合并" class="headerlink" title="循环链表的合并"></a>循环链表的合并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Hebing</span><span class="params">(LinkList &amp;R1, LinkList &amp;R2)</span> </span>&#123;</span><br><span class="line">    Lnode *L1 = R1-&gt;next;  <span class="comment">// R1的头指针</span></span><br><span class="line">    Lnode *L2 = R2-&gt;next;  <span class="comment">// R2的头指针</span></span><br><span class="line">    R1-&gt;next = L2-&gt;next;  <span class="comment">// 连接R1的尾指针与R2的首元结点</span></span><br><span class="line">    R2-&gt;next = L1;  <span class="comment">// 连接R2的尾指针与R1的头结点</span></span><br><span class="line">    <span class="keyword">delete</span> L2;  <span class="comment">// 释放R2头结点内存</span></span><br><span class="line">    <span class="keyword">return</span> R2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双链表结点结构为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Lnode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Lnode *prior;</span><br><span class="line">    Lnode *next;</span><br><span class="line">&#125;Lnode, *LinkList;</span><br></pre></td></tr></table></figure><h3 id="Insert-2"><a href="#Insert-2" class="headerlink" title="Insert"></a>Insert</h3><p>双链表的插入操作，在第n位插入数据为e的结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; L-&gt;data + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Lnode *p = L;</span><br><span class="line">    Lnode *newdata = <span class="keyword">new</span> Lnode;</span><br><span class="line">    newdata-&gt;data = e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        p = p-&gt;next;  <span class="comment">// 找到第n-1位的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    newdata-&gt;next = p-&gt;next;  <span class="comment">// 新节点的next指向原来第n位的节点</span></span><br><span class="line">    newdata-&gt;prior = p;  <span class="comment">// 新节点的prior指向第n-1位的节点</span></span><br><span class="line">    p-&gt;next = newdata;  <span class="comment">// p的next指向新节点</span></span><br><span class="line">    <span class="keyword">if</span> (newdata-&gt;next) newdata-&gt;next-&gt;prior = newdata;  <span class="comment">// 原来第n位的节点的prior指向新节点</span></span><br><span class="line">    L-&gt;data++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete-2"><a href="#Delete-2" class="headerlink" title="Delete"></a>Delete</h3><p>双链表的删除操作，删除第n位的结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; L-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Lnode *p = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        p = p-&gt;next;  <span class="comment">// 找到第n位的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;  <span class="comment">// 第n-1位的节点的next指向第n+1位的节点</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next) p-&gt;next-&gt;prior = p-&gt;prior;  <span class="comment">// 第n+1位的节点的prior指向第n-1位的节点</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    L-&gt;data--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>结点空间可以动态申请与释放</li><li>元素间的逻辑次序靠指针表示，插入删除不需要移动元素</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>存储密度小，每个结点的指针域需额外占用存储空间，存储密度为  结点数据占用空间&#x2F;结点占用总空间  ，指针通常为8字节，顺序表中存储密度为1</li><li>链式存储结构是非随机存取结构，操作时需要从头指针沿链查找该节点，增加了算法的复杂度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS加载动画</title>
      <link href="/2025/06/12/CSS%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/"/>
      <url>/2025/06/12/CSS%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="文本填充效果"><a href="#文本填充效果" class="headerlink" title="文本填充效果"></a>文本填充效果</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/2025/06/12/CSS%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/cssLoading.gif" alt="Loading..."></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">data-text</span>=<span class="string">&quot;Loading...&quot;</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  *&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">10vh</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: skyblue;</span></span><br><span class="line"><span class="language-css">      -webkit-<span class="selector-tag">text</span>-<span class="attribute">stroke</span>: <span class="number">1px</span> yellow;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">h1</span><span class="selector-pseudo">::before</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">content</span>: <span class="built_in">attr</span>(data-text);</span></span><br><span class="line"><span class="language-css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: yellow;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-right</span>: <span class="number">3px</span> solid yellow;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">animation</span>: loading <span class="number">5s</span> linear infinite;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="keyword">@keyframes</span> loading&#123;</span></span><br><span class="line"><span class="language-css">      <span class="number">0%</span>,<span class="number">10%</span>,<span class="number">100%</span>&#123;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="number">70%</span>,<span class="number">90%</span>&#123;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ul><li><code>data-text</code>为自定义属性，属性值为<code>Loading</code></li><li><code>-webkit-text-stroke</code>表示给文字描边</li><li><code>::before</code>为伪类选择器，表示在html结构前添加内容，<code>content</code>为添加的内容，<code>attr</code>表示把属性值作为内容，也可不写<code>attr</code>而直接写内容</li><li><code>position: absolate</code>使伪元素与html内容重合</li><li><code>border-right</code>为伪元素添加右边界，便于通过伪元素宽度的增减实现文本填充的效果</li></ul><h2 id="旋转变色"><a href="#旋转变色" class="headerlink" title="旋转变色"></a>旋转变色</h2><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/2025/06/12/CSS%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/cssloading1.gif"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:1;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:2;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:3;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:4;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:5;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:6;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:7;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:8;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:9;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:10;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:11;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:12;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:13;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:14;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:15;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:16;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:17;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:18;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:19;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;--i:20;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.circle</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attr">--radius</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="built_in">calc</span>(<span class="number">18deg</span> * <span class="built_in">var</span>(--i)));</span></span><br><span class="line"><span class="language-css">        <span class="attribute">animation</span>: ani1 <span class="number">3s</span> linear infinite;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="keyword">@keyframes</span> ani1&#123;</span></span><br><span class="line"><span class="language-css">        <span class="number">0%</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">filter</span>: <span class="built_in">hue-rotate</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="number">100%</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">filter</span>: <span class="built_in">hue-rotate</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item</span><span class="selector-pseudo">::before</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">animation</span>: ani2 <span class="number">2s</span> linear infinite;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">animation-delay</span>: <span class="built_in">calc</span>(<span class="number">0.1s</span> * <span class="built_in">var</span>(--i));</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="keyword">@keyframes</span> ani2 &#123;</span></span><br><span class="line"><span class="language-css">        <span class="number">0%</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="number">100%</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="代码解析"></a>代码解析</h3><ul><li>子绝父相，使每个子元素都重合在左上角，再通过自定义属性<code>--i</code>使子元素旋转不同角度，通过<code>::before</code>添加内容为空的伪元素，形成20个圆组成的圆环</li><li><code>ani1</code>中通过<code>filter: hue-rotate()</code>对色相进行旋转，使之呈现变色的效果</li><li><code>ani2</code>中通过<code>scale</code>缩放伪元素大小，在通过<code>animation-delay</code>对其进行延迟播放，当所有动画都开始播放时正好为动画的起始点，达成循环效果</li><li>伪元素中若没有<code>transform: scale(0)</code>，则会从所有圆大小相同时开始执行</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传与相关操作</title>
      <link href="/2025/06/10/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/06/10/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><p>文件只能通过<strong>两种方式</strong>传输，分别是：通过二进制Blob对象上传(如<code>formData</code>)、通过<code>base64</code>传输，将文件转为<code>base64</code>格式，后端收到后再解码为文件。</p><h2 id="Blob与File"><a href="#Blob与File" class="headerlink" title="Blob与File"></a>Blob与File</h2><p>通过<code>&lt;input&gt;</code>标签上传文件，接收到的文件默认为<code>File</code>对象，<code>Blob</code>为不可变的二进制内容，包含很多操作方法</p><ul><li>通过<code>&lt;input&gt;</code>接受的文件默认为<code>File</code>对象且为数组，<code>multiple</code>表示可接收多个文件</li><li><code>File</code>是<code>Blob</code>的子类，两者可以互相转换</li><li><code>File</code>对象具有<code>name</code>(文件名字)、<code>size</code>(文件大小)、<code>type</code>(文件类型)等属性</li><li><code>Blob</code>对象没有<code>name</code>属性，其余与<code>File</code>相同</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;file&quot; @change=&quot;filechange&quot; multiple /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">const files = ref()</span><br><span class="line">function filechange(e) &#123;</span><br><span class="line">  const file = e.target.files[0]; // e.target.files 即为接收到的文件数组 </span><br><span class="line">  if(file.size &gt; 100000) &#123;</span><br><span class="line">    alert(&quot;文件过大&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  if(file.type !== &quot;image/png&quot;) &#123;</span><br><span class="line">    alert(&quot;文件格式错误&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  const blob = new Blob([file]).slice(0, 5000); // slice表示切割</span><br><span class="line">  const file1 = new File([blob], &quot;img.png&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="FileReader与FormData"><a href="#FileReader与FormData" class="headerlink" title="FileReader与FormData"></a>FileReader与FormData</h2><p>用于把文件读取为某种形式，如<code>base64</code>、<code>text</code>文本</p><ul><li><code>readAsDataURL</code>、<code>readAsText</code>可把文件转化为<code>base64</code>、<code>text</code>格式，读完后把结果放在<code>result</code>属性里</li><li><code>readAsDataURL</code>是<strong>异步操作</strong>，因此必须通过<code>onload</code>来监听读取完成的事件</li><li>**<code>formData</code>**专门用来搭载文件，以二进制的方式传输给后端，可通过<code>append</code>方法添加值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;file&quot; @change=&quot;filechange&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">  &lt;img :src=&quot;img&quot; height=&quot;200px&quot;&gt;&lt;/img&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123;ref&#125; from &quot;vue&quot;</span><br><span class="line">import axios from &quot;axios&quot;</span><br><span class="line">const img = ref()</span><br><span class="line">const file = ref()</span><br><span class="line">function filechange(e) &#123;</span><br><span class="line">  file.value = e.target.files[0]</span><br><span class="line">  const fr = new FileReader()</span><br><span class="line">  fr.readAsDataURL(file.value)</span><br><span class="line">  fr.onload = function() &#123;</span><br><span class="line">    img.value = fr.result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function submit()&#123;</span><br><span class="line">  const fd = new FormData();</span><br><span class="line">  fd.append(&quot;img.png&quot;, file.value) // 两个参数分别表示名字与值</span><br><span class="line">  fd.append(&quot;name&quot;, &quot;abc&quot;)</span><br><span class="line">  axios.post(&quot;&lt;URL&gt;&quot;, fd)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><img src="file.png" alt="image-20250610174135654" style="zoom:67%;" /><h2 id="切片上传"><a href="#切片上传" class="headerlink" title="切片上传"></a>切片上传</h2><p>通过<code>slice</code>方法将文件切片并按顺序上传</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">submit</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> size = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span></span><br><span class="line">  <span class="keyword">let</span> filesize = file.<span class="property">value</span>.<span class="property">size</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (current &lt; filesize) &#123;</span><br><span class="line">    <span class="keyword">let</span> fd = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">    fd.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>, file.<span class="title function_">slice</span>(current, current + size))</span><br><span class="line">    <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&quot;http://localhost:8000&quot;</span>, fd)</span><br><span class="line">    current += size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>网络请求为<strong>异步操作</strong>，因此需要等待请求完毕再继续进行代码，所以需要使用<code>async</code>与<code>await</code></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盒子模型与Flex/Grid布局</title>
      <link href="/2025/06/08/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%B8%8EFlex-Grid%E5%B8%83%E5%B1%80/"/>
      <url>/2025/06/08/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%B8%8EFlex-Grid%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>​<strong>盒子模型</strong>由四部分组成：Margin、Border、Padding、Content。</p><p><img src="https://www.runoob.com/images/box-model.gif" alt="img"></p><p>​分为**标准盒模型(content-box)<strong>与</strong>替代盒模型(border-box)**。</p><h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><ul><li>默认模式，<code>box-sizing: content-box;</code></li><li><code>width/height</code>仅表示<code>Content</code>尺寸</li><li>实际宽度为<code>width(height) + 2*(Padding + Border + Margin)</code></li></ul><h3 id="替代盒模型"><a href="#替代盒模型" class="headerlink" title="替代盒模型"></a>替代盒模型</h3><ul><li>通过<code>box-sizing: border-box</code>来设置</li><li><code>width/height</code>包含<code>Content</code>、<code>Padding</code>、<code>Border</code>的尺寸</li><li>实际宽度为<code>width(height) + 2*Margin</code></li></ul><h3 id="外边距塌陷"><a href="#外边距塌陷" class="headerlink" title="外边距塌陷"></a>外边距塌陷</h3><p>​塌陷指当两个或多个<strong>垂直相邻的块级元素</strong>的外边距相遇时会合并成<strong>单个外边距</strong>的现象。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>两个正外边距时，实际外边距取大的边距，例：20px，50px50px</li><li>一正一负外边距时，实际取两者之和，例：40px，-20px20px</li><li>两个负外边距时，实际外边距取小的边距，例：-20px，-30px-30px</li></ul><h4 id="防止塌陷"><a href="#防止塌陷" class="headerlink" title="防止塌陷"></a>防止塌陷</h4><ul><li><p>使用<strong>BFC</strong>，添加<code>display: flow-root</code></p></li><li><p>添加<code>overflow: hidden; (或 auto, scroll)</code></p></li><li><p><strong>非块级元素</strong>，<code>display: inline-block; width: 100%;</code></p></li><li><p><strong>绝对定位</strong>，<code>position: absolate;</code></p></li><li><p><strong>浮动</strong>，<code>display: float;</code></p></li><li><p>添加隔离层，但会破坏结构</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h2><p>​<strong>一维布局</strong>，通过 <code>display: flex;</code> 或 <code>display: inline-flex;</code> 定义容器。</p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><ul><li>**<code>flex-direction: row | column | row-reverse | column-reverse</code>**，主轴方向，默认为<code>row</code>水平从左到右，<code>column</code>为竖直从上到下，<code>reverse</code>表示方向相反。</li><li>**<code>flex-wrap: no-wrap | wrap | wrap-resverse</code>**，是否换行，默认不换行，换行，反转方向换行。</li><li><strong><code>justify-content: center | space-between | space-around</code><strong>，</strong>主轴</strong>对齐方式，居中，均分但贴紧边缘，均分。</li><li><strong><code>align-items: center</code><strong>，</strong>交叉轴单行</strong>对齐方式，居中。</li><li><code>align-content: center | space-between | space-around</code>，<strong>交叉轴多行</strong>对齐方式，与<code>justify-content</code>相同。</li></ul><p><strong>注意：</strong>多行时使用<code>justify-content: space-between | space-around</code>可能会导致最后一行与前面的行排版不一致，影响美观。</p><h3 id="子类属性"><a href="#子类属性" class="headerlink" title="子类属性"></a>子类属性</h3><ul><li><code>flex-grow: 0</code>，分配剩余空间的放大比例，默认为0</li><li><code>flex-shrink: 1</code>，空间不足时的缩小比例，默认为1，0表示不收缩</li><li><code>flex-basis: auto</code>，设置子项的初始大小，默认为<code>width</code>或<code>height</code></li><li>**<code>flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;</code>**，缩写，通常只写一个数值来表示占剩余空间的份数</li><li><code>order: 0</code>，项目显示顺序，默认为0，越小越靠前</li><li><code>align-self: </code>auto | flex-start&#x2F;end | center | baseline | stretch，元素在<strong>交叉轴</strong>上的排列方式，默认继承父类的<code>align-items</code>，在交叉轴起点&#x2F;终点对齐，在交叉轴中点对齐，按文本基线对齐，拉伸至填满可用空间(无固定尺寸时生效)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex-direction</span>: column;  // 设置主轴为竖直方向</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex-wrap</span>: wrap-reverse;  // 反转换行</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: space-around;  // 设置竖直方向排列方式</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-content</span>: space-between;  // 设置水平方向多行的排列方式</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="box1.png" style="zoom: 67%;" /><h2 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h2><p>​<strong>二维布局</strong>，既能控制行，也能控制列，通过<code>display: grid</code>定义容器。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p><code>grid-template-columns / grid-template-rows: 1fr 2fr 1fr</code>，设置列&#x2F;行的数量及宽度，单位可用<code>fr</code>表示浮动宽度，代表grid的剩余空间，示例表示第二列&#x2F;行占据二分之一</p></li><li><p><code>column-gap / row-gap / gap</code>，设置列&#x2F;行&#x2F;行与列间距</p></li><li><p><code>align-items: center | end</code>，设置竖直方向上居中对齐，靠下对齐</p></li><li><p><code>justify-items: center | end | space-between</code>，水平方向居中对齐，靠右对齐，两端对齐</p></li><li><p><code>align-content: center | end / justify-content: center | end | space-between</code>，若行轨道或列轨道的尺寸小于容器大小，还可对轨道进行对齐，竖直&#x2F;水平方向上居中对齐，向下&#x2F;右对齐，水平上两端对齐</p></li><li><p><code>grid-template-areas</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span>Header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span>Main Content<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span>&gt;</span>Sidebar<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span>Footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.layout</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr; // 设置列得到数量及宽度</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">2</span>fr <span class="number">1</span>fr; // 设置行的数量及高度</span></span><br><span class="line"><span class="language-css">        <span class="attribute">gap</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-template-areas</span>:  </span></span><br><span class="line"><span class="language-css">        <span class="string">&quot;header header header&quot;</span></span></span><br><span class="line"><span class="language-css">        <span class="string">&quot;aside content content&quot;</span></span></span><br><span class="line"><span class="language-css">        <span class="string">&quot;footer footer footer&quot;</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">header</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-area</span>: header;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">aside</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-area</span>: aside;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">main</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-area</span>: content;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">footer</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-area</span>: footer;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="box2.png" style="zoom:50%;" /></li></ul><p><strong>子元素属性</strong></p><ul><li><code>grid-area: areaName | &lt;grid-row-start&gt; &lt;grid-column-start&gt; &lt;grid-row-end&gt; &lt;grid-column-end&gt;</code>，与<code>grid-template-areas</code>结合使用，或直接写精确位置</li><li><code>grid-columns: 1 / 3</code>，<code>grid-rows: 2 / span 2</code>，分别表示，从第一条竖线开始到第三条竖线结束，占两列；从第二条横线开始跨两行</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环与Http缓存</title>
      <link href="/2025/06/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8EHttp%E7%BC%93%E5%AD%98/"/>
      <url>/2025/06/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8EHttp%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h2><ul><li><strong>同步任务：</strong>按顺序逐行执行的代码，需原地等待结果后才继续向下执行</li><li><strong>异步任务：</strong>调用后耗时，不阻塞代码继续执行，在将来完成后触发一个回调函数</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li><strong>调用栈：</strong>存放正在执行的函数调用，顺序为先进后出。</li><li><strong>任务队列：</strong>存储异步函数，包括<code>setTimeout</code>、<code>setInterval</code>、I&#x2F;O事件、UI渲染</li><li><strong>微任务队列：</strong>存储微任务，如Promise的<code>.then .catch .finally</code></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>执行一次宏任务，将<strong>同步代码</strong>存入调用栈并执行；</li><li>处理<strong>微任务</strong>，直到队列清空；</li><li><strong>渲染</strong>页面；</li><li>取一个<strong>宏任务</strong>执行，重复上述步骤</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>微任务优先级<strong>高于</strong>宏任务</li><li>每个宏任务执行后会清空微任务队列</li><li>同类型任务按入队顺序执行</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFuncA</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  <span class="comment">// await 后面的表达式先执行，再将后续 “微任务” 注册到微任务队列</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFuncB</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">  <span class="comment">// 这里没有显式 then，直接 await 会将后续作为微任务</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">asyncFuncNested</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFuncNested</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;nested result&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册多个宏任务与微任务</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFuncA</span>();</span><br><span class="line"><span class="title function_">asyncFuncB</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;13&#x27;</span>);</span><br><span class="line"><span class="comment">// 错误1 2 5 13 3 4 7 8 6 12 9 10 11</span></span><br><span class="line"><span class="comment">// 正确1 2 5 7 13 3 4 8 6 12 9 10 11</span></span><br></pre></td></tr></table></figure><ul><li>先执行同步任务，输出1，<code>setTimeout</code>为宏任务，进入任务队列，<code>asyncFuncA</code>进入队列输出二，执行await后的表达式并将后续代码注册进微任务队列，await后的表达式.then为微任务并进入微任务队列，<code>asyncFuncA</code>离开队列，<code>asyncFuncB</code>进入队列输出5，await后的<code>asyncFuncNested</code>函数进入队列，输出7并将.then注册进微任务队列，<code>asyncFuncNested,asyncFunB</code>离开队列，输出13，同步代码执行完毕，接下来处理微任务</li><li>先是<code>asyncFuncA</code>里await后的.then，输出3，之后执行await后续代码输出4，然后是<code>asyncFuncB</code>里<code>asyncFuncNested</code>里的微任务，输出8，接着执行<code>asyncFuncB</code>里await后续的代码，输出6，微任务执行完毕，接下来处理下一个宏任务</li><li>执行setTimeout里的代码，输出9，.then进入微任务队列，<code>setTimeout</code>进入任务队列，同步代码执行完毕，执行微任务，输出10，取下一个宏任务，输出12</li><li><strong>注意：</strong>async函数中await后的表达式先执行，再将后续代码注册进微任务队列。</li></ul><h2 id="HTTP缓存机制"><a href="#HTTP缓存机制" class="headerlink" title="HTTP缓存机制"></a>HTTP缓存机制</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><strong>强制缓存：</strong>在有效期内，客户端直接使用本地缓存，不向服务器发送请求</li><li><strong>协商缓存：</strong>强制缓存过期后，客户端携带上次响应提供的校验标识(如<code>ETag</code>或<code>Last-Modified</code>)向服务器询问资源是否变化</li></ul><h3 id="关键响应头"><a href="#关键响应头" class="headerlink" title="关键响应头"></a>关键响应头</h3><ul><li><code>Expires</code>：<strong>强制缓存</strong>，示例：<code>Expires: Wed, 21 Oct 2025 07:28:00 GMT</code>，使用GMT格式的绝对时间，<strong>问题</strong>是客户端与服务端时间不一致会导致缓存不准确。</li><li><code>Cache-Control</code>：<strong>强制缓存</strong>，常见指令：<code>max-age=3600</code>(单位为秒)、<code>no-cache</code>(不使用强制缓存)、<code>no-store</code>(禁止缓存)、<code>private``public</code>(只有浏览器可缓存与浏览器、服务器和代理服务器均可缓存)。</li><li><code>Last-Modified</code>：<strong>协商缓存</strong>，资源的最后修改时间，之后客户端会发送值相同的<code>If-Modified-Since</code>，请求时与最后请求时间对比并确定是否继续使用缓存，<strong>问题</strong>是该响应头以秒级别记录，若资源在一秒内发送变化则无法感知到。</li><li><code>ETag</code>：<strong>协商缓存</strong>，首次请求后响应头返回ETag，值为服务器为文件生成的唯一标识，之后请求客户端会发送值为ETag的<code>If-None-Match</code>，将该值与服务器资源的ETag对比。</li></ul><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ul><li><strong>强制缓存：</strong>客户端拿到资源后记录本地缓存的<code>max-age</code>或<code>Expires</code>，下次请求时，若未过期则直接读取本地缓存，不发送网络请求。</li><li><strong>协商缓存：</strong>强制缓存过期后，客户端带上 <code>If-None-Match</code> 或 <code>If-Modified-Since</code> 向服务器发送请求。若未修改，返回304，继续使用本地缓存，且会更新本次的缓存头；若已修改，返回200和新的资源以及新的缓存头。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js-3</title>
      <link href="/2025/06/07/Node-js-3/"/>
      <url>/2025/06/07/Node-js-3/</url>
      
        <content type="html"><![CDATA[<h2 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./router.js&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br><span class="line"><span class="comment">// &#x27;/api&#x27;表示访问该路由时需要加上&#x27;/api&#x27;前缀</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span> , router);</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"><span class="comment">// 创建get接口</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/get&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span>,  <span class="comment">// 状态码</span></span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;get success&#x27;</span>,  <span class="comment">// 响应信息</span></span><br><span class="line">        <span class="attr">data</span>: req.<span class="property">query</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 创建post接口</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/post&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;post success&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: req.<span class="property">body</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h3><p>​cors是express的一个第三方中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>());</span><br></pre></td></tr></table></figure><p>​CORS由一系列<strong>HTTP响应头</strong>组成，这些响应头决定浏览器是否阻止前端JS代码跨域获取资源。</p><p><strong>响应头</strong>：</p><ul><li><code>Access-Control-Allow-Origin: url | *</code>  ，”*”表示允许所有域名的请求，只写域名则表示只允许该域名的请求。</li><li><code>Access-Control-Allow-Headers: xx</code> ，默认情况下CORS仅支持9个请求头，若发送了额外的请求头则需要通过该响应头声明，‘xx’表示要声明的请求头。</li><li><code>Access-Control-Allow-Methods: &#39;POST, GET, DELETE, PUT&#39;</code> ，默认情况下CORS仅支持GET、POST、HEAD请求，若要使用其他方式则需要使用该响应头声明，星号表示所有方法。</li></ul><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><ul><li><p><strong>简单请求：</strong>：请求方式为GET、POST、HEAD三者之一，并且请求头无自定义头部字段且在默认支持的9个请求头范围内。</p></li><li><p><strong>预检请求：</strong>：请求方式为其他请求，或请求头包含自定义头部请求，或向服务器发送了<code>application/json</code>格式的数据。</p><p>在浏览器与服务器正式通信前，浏览器会先发送OPTION请求进行预检，以获知服务器是否允许该实际请求。服务器成功响应预检请求后才会发送真正的请求并携带真实数据。</p></li></ul><h3 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h3><p>​<strong>JSONP：</strong>浏览器通过<code>&lt;script&gt;</code>标签的src属性请求服务器的数据，同时服务器返回函数的调用。</p><ul><li>JSONP不属于Ajax请求，因为没有使用XMLHttpRequest这个对象。</li><li>仅支持GET方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 从客户端得到函数的名称</span></span><br><span class="line">    <span class="keyword">const</span> fnname = req.<span class="property">query</span>.<span class="property">fnname</span>;</span><br><span class="line">    <span class="comment">// 定义要发送到客户端的数据对象</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;jsonp&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拼接出一个函数的调用</span></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="string">`<span class="subst">$&#123;fnname&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span>;</span><br><span class="line">    res.<span class="title function_">send</span>(fn);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js-2</title>
      <link href="/2025/06/03/Node-js-2/"/>
      <url>/2025/06/03/Node-js-2/</url>
      
        <content type="html"><![CDATA[<h2 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h2><p>​<strong>模块化</strong>指自上而下把系统划分成若干模块的过程。</p><p>​<strong>优点：复用性，可维护性，按需加载。</strong></p><h3 id="模块的分类"><a href="#模块的分类" class="headerlink" title="模块的分类"></a><strong>模块的分类</strong></h3><ul><li><strong>内置模块</strong>，由Node.js官方提供；</li><li><strong>自定义模块</strong>，用户创建的每一个js文件都是自定义模块；</li><li><strong>第三方模块</strong>，使用前需先下载。</li></ul><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>​使用<code>require()</code>方法加载模块，加载模块时会执行模块中的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">// 加载自定义模块需要写出文件路径，&quot;.js&quot;可以省略</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">&#x27;./index.js&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h3><p>​与<strong>函数作用域</strong>类似，在自定义模块中定义的变量、方法等只能在当前模块使用。</p><h3 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h3><p>​每个自定义模块中都有一个module对象，里面存储了和当前模块有关的信息，其中<strong>exports</strong>为暴露的对象，通过exports可以使模块内的成员被外界访问到，导入的结果永远以<strong>module.exports指向的对象</strong>为准。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    a,</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exports对象"><a href="#exports对象" class="headerlink" title="exports对象"></a>exports对象</h3><p>​默认情况下，<code>exports</code>与<code>module.exports</code>指向<strong>同一个对象</strong>，最终结果依旧以<strong>module.exports</strong>为准。</p><p>​但是，<strong>不能直接给exports赋值一个对象</strong>，需要对他的属性赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span>.<span class="property">a</span> = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> = &#123;<span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>&#125;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>​默认情况下，<code>exports</code>与<code>module.exports</code>指向<strong>同一个对象</strong>，当直接添加属性时，会在原有的内存里添加属性，但如果对<code>module.exports</code>重新赋值一个对象，就会在内存中开辟一个<strong>新的空间</strong>存放赋值的属性与方法，原来对其属性的赋值都<strong>无效</strong>，也不再与<code>exports</code>指向一个对象。</p><p>​为防止混乱，不要在同一个模块中同时使用<code>exports</code>与<code>module.exports</code>。</p><p>​一个JS模块在node环境中执行时，是被包裹在一个<strong>内置函数</strong>中执行的，格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="variable language_">module</span>, __filename, __dirname</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>​node.js默认支持CommonJS，但浏览器不支持，因此要在浏览器端运行需要经过编译。</p><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><ul><li><pre><code class="js">const express = require(&#39;express&#39;);const app = express();app.get(&#39;/&#39;, (req, res) =&gt; &#123;    // 从客户端得到函数的名称        const fnname = req.query.fnname;    // 定义要发送到客户端的数据对象        const data = &#123;                name: &#39;jsonp&#39;,                age: 18        &#125;        // 拼接出一个函数的调用        const fn = `$&#123;fnname&#125;($&#123;JSON.stringify(data)&#125;)`;        res.send(fn);&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- `package.json`用来记录每个包的下载信息，名字、版本号、下载地址等。</span><br><span class="line"></span><br><span class="line">- `npm init -y`快速创建`package.json`文件。</span><br><span class="line"></span><br><span class="line">- **dependencies节点：**用来记录使用安装了哪些包(**核心依赖包**)。</span><br><span class="line"></span><br><span class="line">- 使用`npm i`命令一次性安装所有dependencies中记录的包。</span><br><span class="line">- **devDependencies节点：**记录只在项目开放阶段使用，上线后不用的包(**开发依赖包**)，安装时在命令中加上`-D`(等价于`--save-dev`)即可。</span><br><span class="line"></span><br><span class="line">- 在执行`npm install`命令时，若添加了`-g`参数，则会安装为全局包。</span><br><span class="line"></span><br><span class="line">### 模块的加载机制</span><br><span class="line"></span><br><span class="line">- 模块在第一次加载后会被缓存，多次调用require()不会导致模块中的代码执行多次。</span><br><span class="line">- **内置模块**加载优先级最高。</span><br><span class="line">- 加载自定义模块路径必须为相对路径，否则会被当做内置模块或第三方模块加载。</span><br><span class="line"></span><br><span class="line">## Express</span><br><span class="line"></span><br><span class="line">​**Express**是基于Node.js平台，快速、开放、极简的**Web开发平台**，与http模块类似。</span><br><span class="line"></span><br><span class="line">​对前端来说，最常见的两种服务器分别是**Web网站服务器**、**API接口服务器**。</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">// 创建服务器</span><br><span class="line">const app = express();</span><br><span class="line">app.get(&#x27;/&#x27;,(req, res) =&gt; &#123;</span><br><span class="line">    // 把内容响应给客户端</span><br><span class="line">    res.send(&quot;666,get成功&quot;);</span><br><span class="line">    console.log(req.query);</span><br><span class="line">&#125;)</span><br><span class="line">app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&quot;666,post成功&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(8000, ()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;server started&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>req.query</strong>可以访问客户端通过<strong>查询字符串</strong>的方式发送的参数，即URL中<strong>“?”</strong>后的参数，格式为<code>?username=abc&amp;age=18</code>。</p></li><li><p><strong>req.params</strong>可以访问URL中通过<strong>“:”</strong>匹配到的动态参数。</p></li><li><p><strong>res.send()<strong>将内容响应给客户端，</strong>必须存在</strong>，否则请求会一直处于待处理状态。</p><p><strong>客户端</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8000/paramsname/paramsage&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;queryname&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求成功，输出 666,get成功</span></span><br></pre></td></tr></table></figure><p><strong>服务端</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/:name/:age&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;666,get成功&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;paramsName = &quot;</span> + req.<span class="property">params</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;paramsAge = &quot;</span> + req.<span class="property">params</span>.<span class="property">age</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;queryName = &quot;</span> + req.<span class="property">query</span>.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 响应成功，输出 paramsName = paramsname paramsAge = paramsage queryName = query</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h4><p>​**express.static()**可以创建一个静态资源服务器，通过如下代码即可将public文件夹中的图片、css文件、js文件对外开放访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br></pre></td></tr></table></figure><p>​如：<a href="http://localhost:8000/img/bg.jpg%EF%BC%8Chttp://localhost:8000/css/index.css%EF%BC%8Chttp://localhost:8000/js/index.js">http://localhost:8000/img/bg.jpg，http://localhost:8000/css/index.css，http://localhost:8000/js/index.js</a></p><p>​Express在指定的目录中查找文件，并对外提供访问路径，因此存放文件的<strong>目录名不会出现在URL中</strong>。</p><p>​若要托管多个静态资源目录，可以多次调用<code>express.static()</code>函数，访问文件时会按顺序查找。</p><h4 id="挂载路径前缀"><a href="#挂载路径前缀" class="headerlink" title="挂载路径前缀"></a>挂载路径前缀</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/public&#x27;</span>, express.<span class="title function_">static</span>(<span class="string">&#x27;./public&#x27;</span>))</span><br></pre></td></tr></table></figure><p>​在访问静态资源时需带有<code>/public</code>前缀</p><p>​如：<a href="http://localhost:8000/public/img/bg.jpg%EF%BC%8Chttp://localhost:8000/public/css/index.css">http://localhost:8000/public/img/bg.jpg，http://localhost:8000/public/css/index.css</a></p><h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a>Express 路由</h2><p>​<strong>路由</strong>指客户端的请求与服务器处理函数之间的映射关系。</p><h3 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a>模块化路由</h3><p>​为方便对路由的管理，推荐将路由抽离为单独的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由模块 route1.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;get sucess&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 导出路由模块</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主文件中</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> route1 = <span class="built_in">require</span>(<span class="string">&#x27;./route1.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 注册模块</span></span><br><span class="line">app.<span class="title function_">use</span>(route1);</span><br><span class="line">app.<span class="property">listen</span>...</span><br></pre></td></tr></table></figure><p>为路由模块<strong>添加前缀</strong>，<code>app.use(&#39;/api&#39;, route1)</code>，添加统一的访问前缀 &#x2F;api。</p><h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><p>​当一个请求到达Express的服务器后，可以连续调用多个<strong>中间件</strong>对这次请求进行<strong>预处理</strong>，最终结果通过路由响应给客户端。</p><p>​中间件本质上是个函数，格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="title function_">next</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​中间件必须包含<strong>next参数</strong>，且必须在最后调用**<code>next()</code>**。</p><p>​next函数表示把流转关系<strong>转交</strong>给下一个中间件或路由。</p><p>​客户端发起的任何请求，到达服务器后都会触发的中间叫做<strong>全局生效</strong>的中间件，格式为<code>app.use((req, res, next) =&gt; &#123;&#125;)</code>。</p><p>​多个中间件之间共享一份req，res，可以在上游的中间件中添加自定义属性或方法供下游使用。</p><p>​<strong>局部生效</strong>的中间件，格式为<code>app.get(&#39;/&#39;, fn(), (req, res) =&gt; &#123;...&#125;)</code>、<code>app.get(&#39;/&#39;, fn1(), fn2() (req, res) =&gt; &#123;...&#125;)</code>或<code>app.get(&#39;/&#39;, [fn1(), fn2()], (req, res) =&gt; &#123;...&#125;)</code>，其中fn、fn1、fn2为中间件。</p><h3 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h3><ul><li><p><strong>应用级别</strong>的中间件，绑定到<strong>app实例</strong>上的中间件。</p></li><li><p><strong>路由级别</strong>的中间件，绑定到<strong>express.Router()实例</strong>上的中间件。</p></li><li><p><strong>错误级别</strong>的中间件专门用来捕获项目中的错误，形参为<code>(err, req, res)</code>，错误级别的中间件必须注册在<strong>所有路由之后</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err, req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(err.<span class="property">message</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>Express内置</strong>的中间件，包括<code>express.static</code>、<code>express.json</code>、<code>express.urlencoded</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析JSON格式的请求体数据</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br><span class="line"><span class="comment">// 解析URL/encoded格式的请求体数据</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span>&#125;));</span><br></pre></td></tr></table></figure><p><code>req.body</code>用来接收客户端发送的请求体数据，若不配置解析表单数据的中间件则默认为<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用axios发送urlencoded格式的数据</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;name=abc&amp;age=18&#x27;</span>);</span><br><span class="line">params.<span class="title function_">append</span>(<span class="string">&#x27;height&#x27;</span>, <span class="number">180</span>); <span class="comment">// 添加数据</span></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8000&#x27;</span>, params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>第三方</strong>的中间件</p></li></ul><h2 id="自定义中间体"><a href="#自定义中间体" class="headerlink" title="自定义中间体"></a>自定义中间体</h2><p>​手写一个将JSON数据解析为对象的中间件，类似于express.json。</p><h3 id="首先编写实现代码"><a href="#首先编写实现代码" class="headerlink" title="首先编写实现代码"></a>首先编写实现代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 解析表单数据的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 监听data事件，获取请求体中的数据，只要有数据就会触发</span></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">        str += chunk;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 监听end事件，当数据传输完成时触发</span></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 将JSON字符串解析为对象</span></span><br><span class="line">        req.<span class="property">body</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line">        <span class="title function_">next</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;post success&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(req.<span class="property">body</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>next()</code>一定要写在监听<strong>end事件函数中</strong>，因为监听事件是异步任务，如果将next()写在外面会直接执行next()，直到同步任务执行完毕才会执行监听事件，导致数据未被处理。</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsonparser.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">        str += chunk;</span><br><span class="line">    &#125;)</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">        req.<span class="property">body</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">        <span class="title function_">next</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> jsonparser = <span class="built_in">require</span>(<span class="string">&#x27;jsonparser&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(jsonparser);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js-1</title>
      <link href="/2025/06/01/Node-js-1/"/>
      <url>/2025/06/01/Node-js-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>​<strong>Node.js</strong>是一个基于Chrome V8引擎的<strong>JS运行环境</strong>。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>浏览器是js的前端执行环境，node.js是js的后端执行环境。</li><li>Node.js中<strong>无法调用</strong>DOM、BOM与AJAX等<strong>浏览器内置API</strong>。</li></ul><h2 id="fs-文件系统模块"><a href="#fs-文件系统模块" class="headerlink" title="fs 文件系统模块"></a>fs 文件系统模块</h2><p>​引用fs模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="fs-readFile"><a href="#fs-readFile" class="headerlink" title="fs.readFile()"></a>fs.readFile()</h3><p>​使用readFile可以读取指定文件中的内容，格式如下(甚至可以我读我自己)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 读取成功err为null</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取失败时data为undefined</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>参数一：必选，字符串，表示文件路径；</li><li>参数二：可选，表示以什么格式来读取文件，一般默认为utf8；</li><li>参数三：必选，表示回调函数，err为错误信息，data为读取到的内容。</li></ul><h3 id="fs-writeFile"><a href="#fs-writeFile" class="headerlink" title="fs.writeFile()"></a>fs.writeFile()</h3><p>​使用writeFile可以向指定的文件中写入内容，格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&quot;666&quot;</span>,<span class="string">&quot;utf8&quot;</span>,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>参数二表示写入的内容，会覆盖文件的原内容；</li><li>回调函数只有err参数，其余部分与readFile相同；</li><li>若文件不存在，则会新建文件。</li></ul><h3 id="处理路径问题"><a href="#处理路径问题" class="headerlink" title="处理路径问题"></a>处理路径问题</h3><p>​如果操作路径是相对路径。容易出现路径动态拼接错误的问题。</p><p> class person<T>{    name:T;    constructer(name: T){        this.name &#x3D; name;    }}ts</p><p>​可以使用<code>__dirname</code>来表示当前文件所处的目录，可通过字符串的拼接来得到完整路径。</p><h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>​<strong>path模块</strong>是Node.js官方提供的用来处理路径的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="path-join"><a href="#path-join" class="headerlink" title="path.join()"></a>path.join()</h3><p>​用来将多个路径片段拼接成一个完整的路径字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">join</span>(__dirname,<span class="string">&quot;/test.txt&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;../&#x27;会抵消一层路经</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">join</span>(<span class="string">&#x27;/a&#x27;</span>,<span class="string">&#x27;/b/c&#x27;</span>,<span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;./d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>)); <span class="comment">// 输出\a\b\d\e</span></span><br></pre></td></tr></table></figure><h3 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename()"></a>path.basename()</h3><p>​通过该方法可以获取路径中的<strong>最后一部分</strong>，通常用basename获取路径中的<strong>文件名</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = path.<span class="title function_">basename</span>(path.<span class="title function_">join</span>(__dirname,<span class="string">&quot;name.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 参数二可选，表示文件后缀名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(test)); <span class="comment">// name.txt</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(test,<span class="string">&quot;.txt&quot;</span>)); <span class="comment">// name</span></span><br></pre></td></tr></table></figure><h3 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname()"></a>path.extname()</h3><p>​用来获取路径中的扩展名，格式为<code>path.extname(path)</code>，返回值为获取的扩展名</p><h2 id="html-模块"><a href="#html-模块" class="headerlink" title="html 模块"></a>html 模块</h2><p>​<strong>http模块</strong>是用来<strong>创建web服务器</strong>的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建server</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line"><span class="comment">// 绑定request事件</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="req请求对象"><a href="#req请求对象" class="headerlink" title="req请求对象"></a>req请求对象</h4><ul><li><p><strong>req.url</strong>是客户端请求的URL地址</p></li><li><p><strong>req.method</strong>是客户端的method请求类型</p></li></ul><h4 id="res响应对象"><a href="#res响应对象" class="headerlink" title="res响应对象"></a>res响应对象</h4><ul><li><code>res.end(test)</code> 其中test为向客户端发送的内容，并结束本次请求</li></ul><h4 id="res-setHeader"><a href="#res-setHeader" class="headerlink" title="res.setHeader()"></a>res.setHeader()</h4><p>​当调用res.end()方法时，想客户端发送中文内容时会出现<strong>乱码</strong>，为此需要在发送前设置响应头。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​参数一为响应头的名字，参数二为该响应头的值。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>​在浏览器访问网址，通过res.url解析出文件路径，再通过fs.readFile()方法读取文件内容，通过res.end()发送给浏览器使html文件呈现在页面上。</p><h3 id="初步代码"><a href="#初步代码" class="headerlink" title="初步代码"></a>初步代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url;</span><br><span class="line">    <span class="comment">// 设置响应头</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">    <span class="comment">// 进行判断并合成地址，如果地址为‘/’则替换为html文件地址</span></span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">url</span> === <span class="string">&#x27;/&#x27;</span> || req.<span class="property">url</span> === <span class="string">&quot;index.html&quot;</span>)&#123;</span><br><span class="line">        url = path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;/page/index.html&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url = path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;/page&quot;</span>, req.<span class="property">url</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(url,<span class="string">&#x27;utf8&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            res.<span class="title function_">end</span>(<span class="string">&#x27;404 not found&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">end</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>浏览器根据 HTTP 响应头里的 <code>Content-Type</code> 来决定如何处理收到的资源。如果你不显式把 CSS 文件的 <code>Content-Type</code> 设置成 <code>text/css</code>，浏览器可能会当作 <code>text/plain</code> 或者二进制流处理，最终就不会应用其中的样式，因此页面上不会显示css内容。</li></ul><p>​因此在响应css请求时需要修改响应头，设置为<code>text/css</code>，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;text/css;charset=utf-8&#x27;</span>);</span><br></pre></td></tr></table></figure><p>然而这样的话每种类型的请求都需要重新设置响应头，过于繁琐，因此可以使用<code>mine-types</code>库。</p><h3 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 导入mime-types</span></span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">&#x27;mime-types&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">url</span> === <span class="string">&#x27;/&#x27;</span> || req.<span class="property">url</span> === <span class="string">&quot;test.html&quot;</span>)&#123;</span><br><span class="line">        url = path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;/page/test.html&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url = path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;/page&quot;</span>, req.<span class="property">url</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(url,<span class="string">&#x27;utf8&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            res.<span class="title function_">end</span>(<span class="string">&#x27;404 not found&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在响应前设置响应头</span></span><br><span class="line">            <span class="comment">// 使用mime.looker()方法可以得到类似&quot;text/html&quot;、&quot;text/css&quot;、&quot;application/javascript&quot;的返回值</span></span><br><span class="line">            res.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, mime.<span class="title function_">lookup</span>(url) + <span class="string">&#x27;;charset=utf-8&#x27;</span>);</span><br><span class="line">            res.<span class="title function_">end</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​除此之外还可以使用<code>mime</code>库，但是需要改为ESM模块，即需要：</p><ol><li><p>在<code>package.json</code>中声明<code>&quot;type&quot;: &quot;module&quot;</code>  或  将js文件后缀改为.mjs；</p></li><li><p>将所有<code>require</code>修改为<code>import</code>，但这样就没有了<code>__dirname</code>；</p></li><li><p>在ESM中重建 <code>__filename</code>与<code>__dirname</code>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span>;</span><br><span class="line"><span class="comment">// fileURLToPath(import.meta.url) 会把类似 &#x27;file:///Users/you/project/server.mjs&#x27; 转成 &#x27;/Users/you/project/server.mjs&#x27;</span></span><br><span class="line"><span class="keyword">const</span> __filename = <span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="comment">// path.dirname(...) 则得出该文件所在的目录</span></span><br><span class="line"><span class="keyword">const</span> __dirname = path.<span class="title function_">dirname</span>(__filename);</span><br></pre></td></tr></table></figure></li><li><p>mime库中与mime-types的lookup方法类似的是getType，其余地方与使用mime-types的方法一致。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript-下-面向对象</title>
      <link href="/2025/05/31/TypeScript-2/"/>
      <url>/2025/05/31/TypeScript-2/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>​除了继承JS的所有特性外，TS还在编译阶段引入了<strong>类(class)<strong>、</strong>接口(interface)<strong>、</strong>泛型(generics)<strong>等语法糖，使我们更容易以</strong>面向对象</strong>的方式编写代码。</p><h3 id="class-类"><a href="#class-类" class="headerlink" title="class(类)"></a>class(类)</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>; <span class="comment">// 默认为public</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span>; <span class="comment">// 可用private关键字修饰属性，此时不可直接调用实例的该属性,需要用get方法来获取</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">sex</span>: <span class="built_in">string</span>; <span class="comment">// readonly表示只读属性，不可被修改</span></span><br><span class="line">    <span class="keyword">static</span> <span class="attr">eyeNum</span>: <span class="built_in">number</span> = <span class="number">2</span>; <span class="comment">// 用static关键字定义类属性(静态属性)或类方法，可直接通过类访问</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="attr">height</span>: <span class="built_in">number</span>; <span class="comment">// protected修饰的属性只能在当前类与子类中使用</span></span><br><span class="line"><span class="comment">// 构造函数，用来初始化实例属性，在创建对象时会调用</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name,age,sex</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 方法，获取age属性值</span></span><br><span class="line">    <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">18</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="property">name</span>); <span class="comment">// abc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="property">age</span>); <span class="comment">// error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="title function_">getAge</span>()); <span class="comment">// 18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">eyeNum</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="property">sex</span>); <span class="comment">// male</span></span><br><span class="line">per.<span class="property">sex</span> = <span class="string">&quot;female&quot;</span>; <span class="comment">// eror</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">sayHi</span>() <span class="comment">// Hi!</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line">    <span class="comment">// 可以直接将属性定义在构造函数中，不需要在定义属性与编写构造函数里的内容</span></span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params"><span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span>,<span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extends-继承"><a href="#extends-继承" class="headerlink" title="extends(继承)"></a>extends(继承)</h3><p>​使用<strong>extends</strong>关键字表示继承，格式为 <code>class 子类 extends 父类&#123;&#125;</code>，子类将会拥有父类所有属性与方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span>; <span class="comment">// 子类只能通过父类的get方法访问private属性</span></span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span>,<span class="attr">age</span>: <span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">animal</span>&#123;</span><br><span class="line">    <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params">name, age, weight</span>)&#123;</span><br><span class="line">        <span class="comment">// super 表示父类，这里表示执行父类的构造函数</span></span><br><span class="line">        <span class="comment">// 若子类重写了构造函数则必须调用父类的构造函数，即super()</span></span><br><span class="line">        <span class="variable language_">super</span>(name, age);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">weight</span> = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法重写，子类覆盖父类方法</span></span><br><span class="line">    <span class="title function_">satyHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;汪汪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">animal</span>&#123;</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;喵喵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title function_">dog</span>(<span class="string">&quot;dog1&quot;</span>,<span class="number">5</span>,<span class="number">15</span>);</span><br><span class="line"><span class="keyword">const</span> cat1 = <span class="keyword">new</span> <span class="title function_">cat</span>(<span class="string">&quot;cat1&quot;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog1.<span class="title function_">getAge</span>()); <span class="comment">// 5</span></span><br><span class="line">dog1.<span class="title function_">sayHi</span>(); <span class="comment">// 汪汪</span></span><br><span class="line">cat1.<span class="title function_">sayHi</span>(); <span class="comment">// 喵喵</span></span><br></pre></td></tr></table></figure><h3 id="abstract-class-抽象类"><a href="#abstract-class-抽象类" class="headerlink" title="abstract class(抽象类)"></a>abstract class(抽象类)</h3><p>​使用<code>abstract</code>关键字修饰class类，使之成为抽象类，抽象类具有以下特征：</p><ul><li>不能用来创建对象，是专门用来被继承的类；</li><li>可以添加抽象方法，使用<code>abstract</code>修饰方法；</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法没有方法体，子类必须对抽象方法进行重写</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">sayHello</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">animal</span> &#123;</span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;wangwang&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title function_">dog</span>(<span class="string">&quot;dog1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ani = <span class="keyword">new</span> <span class="title function_">animal</span>(<span class="string">&quot;ani&quot;</span>); <span class="comment">// error</span></span><br><span class="line">dog1.<span class="title function_">sayHello</span>(); <span class="comment">// wangwang</span></span><br></pre></td></tr></table></figure><h3 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface(接口)"></a>interface(接口)</h3><p>​使用<code>interface</code>关键字声明接口，与普通的类型声明类似</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line"><span class="keyword">type</span> myType = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> myInterface &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person1</span>: myType =&#123;<span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person2</span>: myInterface = &#123;<span class="attr">name</span>:<span class="string">&quot;bbb&quot;</span>&#125;;               </span><br></pre></td></tr></table></figure><p>​但类型声明不能重复被声明，接口可以重复声明，两个接口的并集为最终的接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myType = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> myType = &#123;  <span class="comment">// error</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> myInterface &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> myInterface &#123;</span><br><span class="line"><span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person1</span>: myType =&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person2</span>: myInterface = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>;</span><br><span class="line">&#125;;       </span><br></pre></td></tr></table></figure><p>​接口可以在定义类型的时候限制类的结构，只定义对象的结构，其中的属性不能有实际的值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> myInter&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">sayHello</span>(): <span class="built_in">void</span>; <span class="comment">// 接口中所有方法都是抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义类时可以使类实现一个接口，满足接口的要求</span></span><br><span class="line"><span class="comment">// 该类中必须具有接口的所有属性与方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> <span class="keyword">implements</span> myInter&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性的封装"><a href="#属性的封装" class="headerlink" title="属性的封装"></a>属性的封装</h3><p>​属性可以被任意修改会导致对象中的数据变得非常不安全，使用<strong>封装</strong>可以保证数据的一致性与完整性</p><p>​例如，一个 <code>age</code> 属性可能需要限制在 <code>[0, 150]</code> 之间，如果允许外部直接 <code>person.age = -10</code>，就会导致不合理的状态。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params"><span class="attr">age</span>: <span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter用来读取属性，setter用来修改属性，被称为属性的存取器</span></span><br><span class="line">    <span class="comment">// 写法一</span></span><br><span class="line">    <span class="title function_">getAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setAge</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;=<span class="number">0</span> &amp;&amp; value&lt;=<span class="number">150</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">age</span> = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写法二</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">age</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;=<span class="number">0</span> &amp;&amp; value&lt;=<span class="number">150</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">age</span> = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> <span class="title function_">person</span>(<span class="number">18</span>);</span><br><span class="line"><span class="comment">// 写法一对应的写法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="property">getAge</span>); <span class="comment">// 18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="title function_">setAge</span>(<span class="number">20</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 写法二对应的写法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="property">age</span>)</span><br><span class="line">per.<span class="property">age</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>​<strong>泛型</strong>可以使一个函数能处理多种不同类型的数据，并保证输入输出类型一致时</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn&lt;T，K&gt;(<span class="attr">a</span>: T,<span class="attr">b</span>: K): T&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">10</span>); <span class="comment">// 不指定泛型，TS可自动对类型进行推断</span></span><br><span class="line">fn&lt;<span class="built_in">string</span>,<span class="built_in">number</span>&gt;(<span class="string">&quot;abc&quot;</span>,<span class="number">123</span>); <span class="comment">// 也可指定泛型</span></span><br></pre></td></tr></table></figure><p>​也可与<strong>接口</strong>结合使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IN&#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> fn&lt;T <span class="keyword">extends</span> <span class="variable constant_">IN</span>&gt;(<span class="attr">a</span>: T):<span class="built_in">number</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​定义<strong>类</strong>时也可使用泛型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="attr">name</span>:T;</span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params"><span class="attr">name</span>: T</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript-上-类型与配置</title>
      <link href="/2025/05/30/TypeScript-1/"/>
      <url>/2025/05/30/TypeScript-1/</url>
      
        <content type="html"><![CDATA[<h2 id="TS是什么"><a href="#TS是什么" class="headerlink" title="TS是什么"></a>TS是什么</h2><ul><li><strong>TypeScript</strong>是一门以JS为基础构建的语言。</li><li>TS是JS的<strong>超集</strong>，所有JS代码均可在TS中运行。</li><li>TS扩展了JS，并添加了类型。</li><li><strong>注意</strong>：TS不能被JS解析器直接执行，需要先编译成JS代码。</li></ul><h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>​声明变量时对变量类型进行设置，但即使报错依然会编译成js代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">number</span>;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">&quot;666&quot;</span>; <span class="comment">// error，string类型不能赋值给number类型</span></span><br></pre></td></tr></table></figure><p>​如果同时进行声明与赋值，TS可自动对变量进行类型检测：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">a = <span class="literal">true</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>​也可对函数的参数类型与返回值类型进行声明：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="string">&quot;2&quot;</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h4 id="其他类型："><a href="#其他类型：" class="headerlink" title="其他类型："></a>其他类型：</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">any</span> = <span class="number">1</span>; <span class="comment">// any表示任意类型，相当于关闭了TS的类型检测 </span></span><br><span class="line"><span class="keyword">let</span> b; <span class="comment">// 若不指定类型，自动判断为any</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="built_in">unknown</span> = <span class="number">1</span>; <span class="comment">// unknown表示未知类型的值，实际上是个类型安全的any</span></span><br><span class="line">str = a; <span class="comment">// any类型的值可以赋值给任何类型的值且不报错</span></span><br><span class="line">str = c; <span class="comment">// error</span></span><br><span class="line"><span class="comment">// 类型断言，用来告诉解析器变量的实际类型</span></span><br><span class="line">str = c <span class="keyword">as</span> <span class="built_in">string</span>; </span><br><span class="line">str = &lt;<span class="built_in">string</span>&gt;c; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>): <span class="built_in">void</span>&#123;&#125; <span class="comment">// void表示空值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>): <span class="built_in">never</span>&#123;&#125; <span class="comment">// never表示永远不会返回结果</span></span><br><span class="line"><span class="comment">// &quot;?&quot;表示可选属性，[propName: string]: any表示可添加其他任意类型的属性</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>:&#123;<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>?: <span class="built_in">number</span>, [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125; </span><br><span class="line"><span class="comment">// string[],Array&lt;string&gt;表示字符串数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="built_in">string</span>[]; </span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple 元组"></a>Tuple 元组</h3><p>​<strong>tuple元组</strong>是一种长度固定、数据类型可以不相同的数组类型，可读性与语义性强，类型安全，便于维护，性能优化。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h : [<span class="built_in">string</span>,<span class="built_in">number</span>];</span><br><span class="line">h = [<span class="string">&quot;abc&quot;</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="Enum-枚举"><a href="#Enum-枚举" class="headerlink" title="Enum 枚举"></a>Enum 枚举</h3><p>​<strong>enum枚举</strong>是一种定义一组命名变量的方式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line">    male, <span class="comment">// 默认为0</span></span><br><span class="line">    female <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: &#123;<span class="attr">name</span>: <span class="built_in">string</span>,<span class="attr">gender</span>: <span class="title class_">Gender</span>&#125;;</span><br><span class="line">person = &#123;<span class="attr">name</span>:<span class="string">&quot;abc&quot;</span>, <span class="attr">gender</span>: <span class="title class_">Gender</span>.<span class="property">male</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Gender</span>.<span class="property">male</span>) <span class="comment">// 输出0</span></span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>​当类型需要重复使用时，可以为其起个别名，使用别名代替类型名来简化类型的使用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myType = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: myType;</span><br></pre></td></tr></table></figure><h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// include 用来指定哪些文件需要被编译, exclude 相反</span></span><br><span class="line">    <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;./src/**/*.ts&quot;</span><span class="punctuation">,</span> <span class="comment">// 表示src目录下的所有目录里的所有ts文件</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;name&quot;</span><span class="punctuation">,</span>  <span class="comment">// 表示排除name目录下的所有文件</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// compilerOptions 表示编译器的选项,</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es6&quot;</span><span class="punctuation">,</span> <span class="comment">// 用来指定编译后的JS代码的目标版本，默认为ES3</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定编译后的JS代码的模块化规范</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定编译后文件的输出目录</span></span><br><span class="line">    <span class="attr">&quot;outfile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/test.js&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定编译后文件的输出文件名并将文件合为一个文件</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;dom&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 指定项目中使用的库，一般不需要手动指定</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否允许编译JS文件，默认为false</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否检查JS文件的类型，默认为false</span></span><br><span class="line">        <span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 编译后是否移除注释</span></span><br><span class="line">        <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 编译后是否生成 .js 文件</span></span><br><span class="line">    <span class="attr">&quot;noEmitOnError&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 编译出错时是否生成.js 文件</span></span><br><span class="line">        </span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否启用所有严格类型检查选项</span></span><br><span class="line">    <span class="comment">// 是否始终启用严格模式, 默认为false，如果为true，则会在生成文件的顶部添加&quot;use strict&quot;</span></span><br><span class="line">    <span class="comment">// 若文件使用了ES6的模块语法，js文件会自动进入严格模式</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 不允许隐式的any类型</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 不允许隐式的this类型</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite</title>
      <link href="/2025/05/29/Vite/"/>
      <url>/2025/05/29/Vite/</url>
      
        <content type="html"><![CDATA[<h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h2><p>​与<strong>webpack</strong>相同，<strong>Vite</strong>也是前端的构建工具。</p><h2 id="与webpack的不同"><a href="#与webpack的不同" class="headerlink" title="与webpack的不同"></a>与webpack的不同</h2><ul><li>开发时使用<strong>ESM</strong>的方式来运行项目，而不对代码进行打包。</li><li>生产时使用<strong>Rollup</strong>打包方式</li><li>可自动处理常见静态资源，无需像webpack一样配置loader。</li><li>配置简单，开箱即用，无需手动配置。</li></ul><h2 id="Plugins-插件"><a href="#Plugins-插件" class="headerlink" title="Plugins(插件)"></a>Plugins(插件)</h2><p>​Vite也可使用<strong>plugins</strong>，使用方法与webpack类似。</p><p>​配置文件格式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>; <span class="comment">// 可有可无，若不添加则写为 export default&#123;&#125;</span></span><br><span class="line"><span class="comment">// 使用es6的模块化来暴露文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">plugins</span>: [],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​如要使传统浏览器支持可使用<code>@vitejs/plugin-legacy</code>：</p><p>​安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add -D @vitejs/plugin-legacy</span><br></pre></td></tr></table></figure><p>​使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> legacy <span class="keyword">from</span><span class="string">`@vitejs/plugin-legacy`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">legacy</span>(&#123;</span><br><span class="line">      <span class="attr">targets</span>:[<span class="string">&#x27;defaults&#x27;</span>,<span class="string">&quot;ie 11&quot;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="启动速度快"><a href="#启动速度快" class="headerlink" title="启动速度快"></a>启动速度快</h3><ul><li><strong>Vite</strong>：使用<strong>ESM</strong>功能，启动时无需打包。</li><li><strong>Webpack</strong>：启动时需重新构建整个模块依赖图，即使是微小变动也需要重新打包。</li></ul><h3 id="高效能热更新"><a href="#高效能热更新" class="headerlink" title="高效能热更新"></a>高效能热更新</h3><ul><li><strong>Vite</strong>：使用模块级热更新，仅更新被修改的模块。</li><li><strong>Webpack</strong>：每次修改都会触发重打包。</li></ul><h3 id="原生ESM支持"><a href="#原生ESM支持" class="headerlink" title="原生ESM支持"></a>原生ESM支持</h3><ul><li>浏览器原生ESM是未来主流，Vite便基于此设计。</li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>作为新兴构建工具，插件生态不如webpack丰富。</li><li>对老旧浏览器支持不佳。</li><li>不适合高度定制化构建流程的大型项目。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 构建工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2025/05/28/webpack/"/>
      <url>/2025/05/28/webpack/</url>
      
        <content type="html"><![CDATA[<p>​<strong>webpack</strong>是一个现代JS应用的一个<strong>模块打包器</strong>，作用为将所有资源（JS，css，图片等）打包为多个静态文件。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>​写在webpack.config.js中，格式为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Entry-入口-Output-出口"><a href="#Entry-入口-Output-出口" class="headerlink" title="Entry(入口)  Output(出口)"></a>Entry(入口)  Output(出口)</h3><p>​入口文件与出口文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 入口文件</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">// 入口文件路径</span></span><br><span class="line">  <span class="comment">// 出口文件</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span>, <span class="comment">// 出口文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 出口文件路径,必须绝对路径</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">// 每次构建是否清除path目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Mode-模式"><a href="#Mode-模式" class="headerlink" title="Mode(模式)"></a>Mode(模式)</h3><p>​用于设置编译模式，可选  “production”,”development”,”none”</p><ul><li>production：生产模式，开启代码压缩，如：删除未用到的代码；</li><li>development：开发模式，保留注释，不压缩代码。</li></ul><h3 id="Loaders-加载器"><a href="#Loaders-加载器" class="headerlink" title="Loaders(加载器)"></a>Loaders(加载器)</h3><p>​原生webpack只能打包JS与JSON代码，因此要打包其他资源需要对应的<strong>Loader</strong>（或资源模块Asset Moudules）。</p><p>​如要解析css文件就需要style-loader与css-loader：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/i</span>, <span class="comment">// 指定哪些文件需要被处理，形式为正则表达式</span></span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>], <span class="comment">// 使用哪些loader进行处理,执行顺序为从后往前执行</span></span><br><span class="line">        <span class="comment">// css-loader只负责将css文件转为js，style-loader处理css文件并插入到html中</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Plugins-插件"><a href="#Plugins-插件" class="headerlink" title="Plugins(插件)"></a>Plugins(插件)</h3><p>​不对代码进行处理，但会拓展一些功能，在生命周期中注入或修改行为。</p><p>​如使用<strong>HtmlWebpackPlugin</strong>插件在构建时根据模版生成html并自动注入打包资源：</p><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure></li><li><p>在配置中引入并实例化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="comment">// 引入html-webpack-plugin插件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HTMLPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HTMLPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;test&#x27;</span>, <span class="comment">// 配置生成html文件的标题</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> <span class="comment">// 配置生成html文件的模板</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span>, <span class="comment">// 配置生成html文件的名称</span></span><br><span class="line">      <span class="attr">inject</span>: <span class="string">&#x27;body&#x27;</span>, <span class="comment">// 配置html文件插入的位置,放在&lt;/body&gt;前</span></span><br><span class="line">      <span class="attr">minify</span>: <span class="literal">true</span> <span class="comment">// 配置html文件的压缩,打包时压缩html</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Asset-Modules-资源模块"><a href="#Asset-Modules-资源模块" class="headerlink" title="Asset Modules(资源模块)"></a>Asset Modules(资源模块)</h3><p>​<strong>Asset Modules</strong> 是从 <strong>Webpack 5</strong> 开始引入的一种 <strong>新的资源模块类型</strong>，用于代替旧版中通过 <code>file-loader</code>、<code>url-loader</code> 和 <code>raw-loader</code> 等处理静态资源的方式。让我们在不额外安装loader的情况下即可处理一些静态资源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg,png)$/i</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Devtool"><a href="#Devtool" class="headerlink" title="Devtool*"></a>Devtool*</h3><p>​用来控制如何生成**Source Map(源码映射)**，安装source-map，使源码在浏览器的源代码中可见并可调试。</p><p>​不同的devtool模式，其构建速度、打包体积和映射精度各不相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NodePolyfillPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;node-polyfill-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;inline-source-map&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 构建工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP的三次握手与四次挥手</title>
      <link href="/2025/05/23/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2025/05/23/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、三次握手"><a href="#一、三次握手" class="headerlink" title="一、三次握手"></a>一、三次握手</h2><h3 id="第一次：SYN（同步请求）"><a href="#第一次：SYN（同步请求）" class="headerlink" title="第一次：SYN（同步请求）"></a>第一次：SYN（同步请求）</h3><p>​·  客户端发送带有SYN标志位（SYN&#x3D;1）的报文，并随机生成一个初始序列号。</p><p>​·  告知服务器希望建立连接，并提供初始序列号用于后续数据顺序校验。</p><h3 id="第二次：SYN-ACK（同步确认）"><a href="#第二次：SYN-ACK（同步确认）" class="headerlink" title="第二次：SYN-ACK（同步确认）"></a>第二次：SYN-ACK（同步确认）</h3><p>​·  服务器收到SYN报文后，记录客户端的初始序列号（ISN_C），回复SYN-ACK报文（SYN&#x3D;1,ACK&#x3D;1）。</p><p>​·  SYN-ACK报文包含自己的初始序列号（ISN_S）和确认号（ACK&#x3D;ISN_C+1）.</p><p>​·  表示已收到客户端的SYN，确认客户端的连接请求，同时声明自身的初始序列号。</p><h3 id="第三次：ACK（最终确认）"><a href="#第三次：ACK（最终确认）" class="headerlink" title="第三次：ACK（最终确认）"></a>第三次：ACK（最终确认）</h3><p>​·  客户端收到SYN-ACK报文后发送ACK报文（ACK&#x3D;1），确认号为ISN_S+1。</p><p>​·  客户端确认服务器的响应，双方确认连接可靠。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>​·  交换初始序列号确保数据按需传输；</p><p>​·  验证双方均具备发送与接受信息的能力，确保双向通信。</p><h3 id="为何需要三次？"><a href="#为何需要三次？" class="headerlink" title="为何需要三次？"></a>为何需要三次？</h3><p>​<strong>两次握手：</strong>若在第二次握手后直接分配资源，但客户端未收到SYN-ACK或未响应ACK，服务器资源会被长期占用。</p><p>​<strong>四次握手：</strong>三次已经足够实现功能，第四次交互只会增加延迟。</p><h2 id="二、四次握手"><a href="#二、四次握手" class="headerlink" title="二、四次握手"></a>二、四次握手</h2><h3 id="第一次：FIN"><a href="#第一次：FIN" class="headerlink" title="第一次：FIN"></a>第一次：FIN</h3><p>​·  <strong>客户端</strong>发送FIN报文（FIN&#x3D;1），序列号为seq&#x3D;u，进入FIN_WAIT_1状态，表示不再发送数据，但可接收数据。</p><h3 id="第二次：ACK"><a href="#第二次：ACK" class="headerlink" title="第二次：ACK"></a>第二次：ACK</h3><p>​·  <strong>服务器</strong>收到FIN后，回复ACK报文（ACK&#x3D;1），确认号ack&#x3D;u+1，进入CLOSE_WAIT状态，此时：</p><p>​·  客户端到服务器的连接关闭（单项关闭）；</p><p>​·  服务器可能继续发送未完成的数据。</p><p>​·  客户端收到ACK报文后进入FIN_WAIT_2状态，等待服务器的FIN报文。</p><h3 id="第三次：FIN"><a href="#第三次：FIN" class="headerlink" title="第三次：FIN"></a>第三次：FIN</h3><p>​·  <strong>服务端</strong>处理完数据后发送FIN报文（FIN&#x3D;1,ACK&#x3D;1），序列号seq&#x3D;v，确认号为ack&#x3D;u+1，进入LAST_ACK状态，表示准备关闭连接。</p><h3 id="第四次：ACK"><a href="#第四次：ACK" class="headerlink" title="第四次：ACK"></a>第四次：ACK</h3><p>​·  <strong>客户端</strong>收到FIN后，回复ACK报文（ACK&#x3D;1），确认号ack&#x3D;v+1，进入TIME_WAIT状态，等待一段时间后关闭连接。</p><p>​·  <strong>服务器</strong>收到ACK后立即关闭连接。</p><h3 id="TIME-WAIT状态的作用"><a href="#TIME-WAIT状态的作用" class="headerlink" title="TIME_WAIT状态的作用"></a>TIME_WAIT状态的作用</h3><p>​·  确保最后一个ACK到达被动关闭方。若ACK丢失，被动方会重传FIN，主动方需重新响应。</p><p>​·  防止旧连接的报文干涉新连接。</p><h3 id="为何需要四次挥手"><a href="#为何需要四次挥手" class="headerlink" title="为何需要四次挥手"></a>为何需要四次挥手</h3><p>​TCP每个方向需独立关闭。被动方肯可能在发送ACK后仍有数据发送，因此需将ACK与FIN分开发送，导致四次交互。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从输入URL到出现页面</title>
      <link href="/2025/05/23/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E5%87%BA%E7%8E%B0%E9%A1%B5%E9%9D%A2/"/>
      <url>/2025/05/23/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E5%87%BA%E7%8E%B0%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、解析URL"><a href="#一、解析URL" class="headerlink" title="一、解析URL"></a>一、解析URL</h2><p>​·  浏览器解析输入的URL，检查协议、域名、端口和路径。</p><p>​·  若是非完整URL（如输入baidu.com），浏览器会尝试补全（自动添加https:&#x2F;&#x2F;）。</p><h2 id="二、检查缓存"><a href="#二、检查缓存" class="headerlink" title="二、检查缓存"></a>二、检查缓存</h2><p>​·  浏览器检查HSTS列表，若域名在列表中，自动将HTTP请求升级成HTTPS。</p><p>​·  查看本地缓存是否有该资源的缓存副本，若有效则直接使用。</p><h2 id="三、DNS解析"><a href="#三、DNS解析" class="headerlink" title="三、DNS解析"></a>三、DNS解析</h2><p>​·  每个网址都有对应的ip地址，ip地址有数字组成，不便于记忆，将url地址解析为ip地址的过程就是<strong>DNS解析</strong>。</p><p>​·  DNS就是一个记录着url与其对应的ip地址的数据库。</p><p>​·  将域名转换为ip地址：</p><p>​1.浏览器缓存–&gt;系统缓存（hosts文件）–&gt;路由器缓存–&gt;ISP的DNS服务器。</p><p>​2.若未命中缓存，DNS服务器通过递归查询（如根域名服务器–&gt;顶级域名服务器–&gt;权威域名服务器）。</p><h2 id="四、建立TCP连接"><a href="#四、建立TCP连接" class="headerlink" title="四、建立TCP连接"></a>四、建立TCP连接</h2><p>​·  通过<a href="/2025/05/23/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">三次握手</a>建立连接</p><p>​·  如果是HTTPS，还需进行TLS握手：</p><p>​1.协商加密套件；</p><p>​2.服务器发送证书（由CA机构签发，验证身份）；</p><p>​3.生成会话秘钥（Session Key）,后续通信加密。</p><h2 id="五、发送HTTP请求"><a href="#五、发送HTTP请求" class="headerlink" title="五、发送HTTP请求"></a>五、发送HTTP请求</h2><p>​·  浏览器发送HTTP请求：</p><p>​·  请求行（&lt;请求方式&gt;&lt;请求URL&gt;&lt;HTTP版本&gt;）</p><p>​·  请求头（如User-Agent、Accept、Cookie）</p><p>​·  请求体（如POST方法的表单数据）</p><p>​·  如果是HTTPS，数据会被TLS加密。</p><h2 id="六、服务器处理请求"><a href="#六、服务器处理请求" class="headerlink" title="六、服务器处理请求"></a>六、服务器处理请求</h2><p>​·  服务器接收请求</p><p>​·  生成响应</p><h2 id="七、接受响应并解析"><a href="#七、接受响应并解析" class="headerlink" title="七、接受响应并解析"></a>七、接受响应并解析</h2><p>​·  浏览器接收响应：</p><p>​·  状态码（2xx成功、3xx重定向、4xx客户端错误、5xx服务端错误）</p><p>​·  响应头（Content-Type、Cache-Control、Set-Cookie等）</p><p>​·  响应体（HTML、CSS、JS等）</p><p>​·  解析HTML</p><h2 id="八、加载子资源"><a href="#八、加载子资源" class="headerlink" title="八、加载子资源"></a>八、加载子资源</h2><p>​·  解析过程发现图片、CSS、JS等资源时，重新触发HTTP请求（可能复用TCP连接）</p><p>​·  现代浏览器会通过预加载扫描器提前下载资源</p><h2 id="九、渲染页面"><a href="#九、渲染页面" class="headerlink" title="九、渲染页面"></a>九、渲染页面</h2><p>​· 布局，绘制，合成</p><h2 id="十、连接关闭"><a href="#十、连接关闭" class="headerlink" title="十、连接关闭"></a>十、连接关闭</h2><p>​·  通过<a href="/2025/05/23/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">TCP的四次挥手</a>关闭连接</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2025/05/20/%E9%97%AD%E5%8C%85/"/>
      <url>/2025/05/20/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​当内部函数引用了外部函数的变量，即使外部函数执行完毕，其作用域也不会被销毁，而是被内部函数保留。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>​·   允许函数访问并记住其定义时的词法作用域。</p><p>​·   在定义时确定作用域，而非执行时，内部函数可以访问外部函数的变量、参数和函数。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(++count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">outer</span>();  <span class="comment">// 输出1</span></span><br><span class="line"><span class="title function_">outer</span>();  <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>​1.数据封装私有化：隐藏变量，只通过特定变量接口暴露操作；</p><p>​2.保留函数状态：可用于 计数器、缓存、防抖&#x2F;节流函数；</p><p>​3.模块化开发：结合立即执行函数可以隔离作用域，避免全局污染。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>​有内存泄漏风险：及时解除闭包引用，obj&#x3D;null。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/05/18/hello-world/"/>
      <url>/2025/05/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>列表</title>
      <link href="/list/index.html"/>
      <url>/list/index.html</url>
      
        <content type="html"><![CDATA[<p>666</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<ul class=list>    <li>        <a href="https://qinchuid.github.io/">            <span class=img><img  src="/img/xiaodi.jpg"></span>            <div class="name">琴吹滴</div>            <div class="jieshao">不熟</div>        </a>    </li>    <li>        <a href="https://benksih.github.io">            <span class=img><img  src="/img/benksih.jpg"></span>            <div class="name">Benksih</div>            <div class="jieshao">不认识</div>        </a>    </li>    </ul><style>    .list{        list-style: none;    }    .list li{        height: 210px;        width: 140px;        float: left;    }    .list li a:hover{        transform: scale(1.1);        transition: all .3s;        box-shadow: 0 0 15px #00c4b6;        border-radius: 10px;        text-decoration: none;    }    .list li a{        display: flex;        flex-direction: column;        justify-content: center;        align-items: center;                flex-wrap: wrap;    }    .list img{        width: 100px;        height: 100px;    }    .list li .img{        width: 100px;        height: 100px;        border-radius: 50%;        overflow: hidden;    }    .list li .name{        font-size: 18px;        font-weight: 700;        color: rgb(0, 0, 0);    }    .list li .jieshao{        font-size: 14px;        color: rgba(0, 0, 0,.5);    }</style>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
